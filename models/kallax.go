// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package models

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/google/go-github/github"
	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewIssue returns a new instance of Issue.
func NewIssue() (record *Issue) {
	return new(Issue)
}

// GetID returns the primary key of the model.
func (r *Issue) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Issue) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "id":
		return types.Nullable(&r.Issue.ID), nil
	case "number":
		return types.Nullable(&r.Issue.Number), nil
	case "state":
		return types.Nullable(&r.Issue.State), nil
	case "locked":
		return types.Nullable(&r.Issue.Locked), nil
	case "title":
		return types.Nullable(&r.Issue.Title), nil
	case "body":
		return types.Nullable(&r.Issue.Body), nil
	case "comments":
		return types.Nullable(&r.Issue.Comments), nil
	case "closed_at":
		return types.Nullable(&r.Issue.ClosedAt), nil
	case "created_at":
		return types.Nullable(&r.Issue.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.Issue.UpdatedAt), nil
	case "htmlurl":
		return types.Nullable(&r.Issue.HTMLURL), nil
	case "node_id":
		return types.Nullable(&r.Issue.NodeID), nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil
	case "labels":
		return types.Slice(&r.LabelList), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "assignee_id":
		return &r.AssigneeID, nil
	case "assignee_login":
		return &r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(&r.AssigneesList), nil
	case "closed_by_id":
		return &r.ClosedByID, nil
	case "closed_by_login":
		return &r.ClosedByLogin, nil
	case "milestone_id":
		return &r.MilestoneID, nil
	case "milestone_title":
		return &r.MilestoneTitle, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Issue: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Issue) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "id":
		if r.Issue.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.Issue.ID, nil
	case "number":
		if r.Issue.Number == (*int)(nil) {
			return nil, nil
		}
		return r.Issue.Number, nil
	case "state":
		if r.Issue.State == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.State, nil
	case "locked":
		if r.Issue.Locked == (*bool)(nil) {
			return nil, nil
		}
		return r.Issue.Locked, nil
	case "title":
		if r.Issue.Title == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.Title, nil
	case "body":
		if r.Issue.Body == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.Body, nil
	case "comments":
		if r.Issue.Comments == (*int)(nil) {
			return nil, nil
		}
		return r.Issue.Comments, nil
	case "closed_at":
		if r.Issue.ClosedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Issue.ClosedAt, nil
	case "created_at":
		if r.Issue.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Issue.CreatedAt, nil
	case "updated_at":
		if r.Issue.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Issue.UpdatedAt, nil
	case "htmlurl":
		if r.Issue.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.HTMLURL, nil
	case "node_id":
		if r.Issue.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.NodeID, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil
	case "labels":
		return types.Slice(r.LabelList), nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "assignee_id":
		return r.AssigneeID, nil
	case "assignee_login":
		return r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(r.AssigneesList), nil
	case "closed_by_id":
		return r.ClosedByID, nil
	case "closed_by_login":
		return r.ClosedByLogin, nil
	case "milestone_id":
		return r.MilestoneID, nil
	case "milestone_title":
		return r.MilestoneTitle, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Issue: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Issue) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Issue has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Issue) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Issue has no relationships")
}

// IssueStore is the entity to access the records of the type Issue
// in the database.
type IssueStore struct {
	*kallax.Store
}

// NewIssueStore creates a new instance of IssueStore
// using a SQL database.
func NewIssueStore(db *sql.DB) *IssueStore {
	return &IssueStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *IssueStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *IssueStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *IssueStore) Debug() *IssueStore {
	return &IssueStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *IssueStore) DebugWith(logger kallax.LoggerFunc) *IssueStore {
	return &IssueStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *IssueStore) DisableCacher() *IssueStore {
	return &IssueStore{s.Store.DisableCacher()}
}

// Insert inserts a Issue in the database. A non-persisted object is
// required for this operation.
func (s *IssueStore) Insert(record *Issue) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Issue.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *IssueStore) Update(record *Issue, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Issue.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *IssueStore) Save(record *Issue) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *IssueStore) Delete(record *Issue) error {
	return s.Store.Delete(Schema.Issue.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *IssueStore) Find(q *IssueQuery) (*IssueResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewIssueResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *IssueStore) MustFind(q *IssueQuery) *IssueResultSet {
	return NewIssueResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *IssueStore) Count(q *IssueQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *IssueStore) MustCount(q *IssueQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *IssueStore) FindOne(q *IssueQuery) (*Issue, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *IssueStore) FindAll(q *IssueQuery) ([]*Issue, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *IssueStore) MustFindOne(q *IssueQuery) *Issue {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Issue with the data in the database and
// makes it writable.
func (s *IssueStore) Reload(record *Issue) error {
	return s.Store.Reload(Schema.Issue.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *IssueStore) Transaction(callback func(*IssueStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&IssueStore{store})
	})
}

// IssueQuery is the object used to create queries for the Issue
// entity.
type IssueQuery struct {
	*kallax.BaseQuery
}

// NewIssueQuery returns a new instance of IssueQuery.
func NewIssueQuery() *IssueQuery {
	return &IssueQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Issue.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *IssueQuery) Select(columns ...kallax.SchemaField) *IssueQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *IssueQuery) SelectNot(columns ...kallax.SchemaField) *IssueQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *IssueQuery) Copy() *IssueQuery {
	return &IssueQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *IssueQuery) Order(cols ...kallax.ColumnOrder) *IssueQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *IssueQuery) BatchSize(size uint64) *IssueQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *IssueQuery) Limit(n uint64) *IssueQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *IssueQuery) Offset(n uint64) *IssueQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *IssueQuery) Where(cond kallax.Condition) *IssueQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *IssueQuery) FindByKallaxID(v ...int64) *IssueQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Issue.KallaxID, values...))
}

// FindByClosedAt adds a new filter to the query that will require that
// the ClosedAt property is equal to the passed value.
func (q *IssueQuery) FindByClosedAt(cond kallax.ScalarCond, v time.Time) *IssueQuery {
	return q.Where(cond(Schema.Issue.ClosedAt, v))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *IssueQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *IssueQuery {
	return q.Where(cond(Schema.Issue.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *IssueQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *IssueQuery {
	return q.Where(cond(Schema.Issue.UpdatedAt, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *IssueQuery) FindByRepositoryOwner(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *IssueQuery) FindByRepositoryName(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.RepositoryName, v))
}

// FindByLabelList adds a new filter to the query that will require that
// the LabelList property contains all the passed values; if no passed values,
// it will do nothing.
func (q *IssueQuery) FindByLabelList(v ...string) *IssueQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Issue.LabelList, values...))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *IssueQuery) FindByUserID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *IssueQuery) FindByUserLogin(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.UserLogin, v))
}

// FindByAssigneeID adds a new filter to the query that will require that
// the AssigneeID property is equal to the passed value.
func (q *IssueQuery) FindByAssigneeID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.AssigneeID, v))
}

// FindByAssigneeLogin adds a new filter to the query that will require that
// the AssigneeLogin property is equal to the passed value.
func (q *IssueQuery) FindByAssigneeLogin(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.AssigneeLogin, v))
}

// FindByClosedByID adds a new filter to the query that will require that
// the ClosedByID property is equal to the passed value.
func (q *IssueQuery) FindByClosedByID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.ClosedByID, v))
}

// FindByClosedByLogin adds a new filter to the query that will require that
// the ClosedByLogin property is equal to the passed value.
func (q *IssueQuery) FindByClosedByLogin(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.ClosedByLogin, v))
}

// FindByMilestoneID adds a new filter to the query that will require that
// the MilestoneID property is equal to the passed value.
func (q *IssueQuery) FindByMilestoneID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.MilestoneID, v))
}

// FindByMilestoneTitle adds a new filter to the query that will require that
// the MilestoneTitle property is equal to the passed value.
func (q *IssueQuery) FindByMilestoneTitle(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.MilestoneTitle, v))
}

// IssueResultSet is the set of results returned by a query to the
// database.
type IssueResultSet struct {
	ResultSet kallax.ResultSet
	last      *Issue
	lastErr   error
}

// NewIssueResultSet creates a new result set for rows of the type
// Issue.
func NewIssueResultSet(rs kallax.ResultSet) *IssueResultSet {
	return &IssueResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *IssueResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Issue.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Issue)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Issue")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *IssueResultSet) Get() (*Issue, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *IssueResultSet) ForEach(fn func(*Issue) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *IssueResultSet) All() ([]*Issue, error) {
	var result []*Issue
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *IssueResultSet) One() (*Issue, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *IssueResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *IssueResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewIssueComment returns a new instance of IssueComment.
func NewIssueComment() (record *IssueComment) {
	return new(IssueComment)
}

// GetID returns the primary key of the model.
func (r *IssueComment) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *IssueComment) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "id":
		return types.Nullable(&r.IssueComment.ID), nil
	case "node_id":
		return types.Nullable(&r.IssueComment.NodeID), nil
	case "body":
		return types.Nullable(&r.IssueComment.Body), nil
	case "reactions":
		if r.Reactions == nil {
			r.Reactions = new(github.Reactions)
		}
		return types.JSON(r.IssueComment.Reactions), nil
	case "created_at":
		return types.Nullable(&r.IssueComment.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.IssueComment.UpdatedAt), nil
	case "author_association":
		return types.Nullable(&r.IssueComment.AuthorAssociation), nil
	case "htmlurl":
		return types.Nullable(&r.IssueComment.HTMLURL), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "issue_number":
		return &r.IssueNumber, nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in IssueComment: %s", col)
	}
}

// Value returns the value of the given column.
func (r *IssueComment) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "id":
		if r.IssueComment.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.IssueComment.ID, nil
	case "node_id":
		if r.IssueComment.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.IssueComment.NodeID, nil
	case "body":
		if r.IssueComment.Body == (*string)(nil) {
			return nil, nil
		}
		return r.IssueComment.Body, nil
	case "reactions":
		if r.IssueComment.Reactions == (*github.Reactions)(nil) {
			return nil, nil
		}
		return types.JSON(r.IssueComment.Reactions), nil
	case "created_at":
		if r.IssueComment.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.IssueComment.CreatedAt, nil
	case "updated_at":
		if r.IssueComment.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.IssueComment.UpdatedAt, nil
	case "author_association":
		if r.IssueComment.AuthorAssociation == (*string)(nil) {
			return nil, nil
		}
		return r.IssueComment.AuthorAssociation, nil
	case "htmlurl":
		if r.IssueComment.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.IssueComment.HTMLURL, nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "issue_number":
		return r.IssueNumber, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in IssueComment: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *IssueComment) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model IssueComment has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *IssueComment) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model IssueComment has no relationships")
}

// IssueCommentStore is the entity to access the records of the type IssueComment
// in the database.
type IssueCommentStore struct {
	*kallax.Store
}

// NewIssueCommentStore creates a new instance of IssueCommentStore
// using a SQL database.
func NewIssueCommentStore(db *sql.DB) *IssueCommentStore {
	return &IssueCommentStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *IssueCommentStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *IssueCommentStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *IssueCommentStore) Debug() *IssueCommentStore {
	return &IssueCommentStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *IssueCommentStore) DebugWith(logger kallax.LoggerFunc) *IssueCommentStore {
	return &IssueCommentStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *IssueCommentStore) DisableCacher() *IssueCommentStore {
	return &IssueCommentStore{s.Store.DisableCacher()}
}

// Insert inserts a IssueComment in the database. A non-persisted object is
// required for this operation.
func (s *IssueCommentStore) Insert(record *IssueComment) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.IssueComment.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *IssueCommentStore) Update(record *IssueComment, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.IssueComment.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *IssueCommentStore) Save(record *IssueComment) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *IssueCommentStore) Delete(record *IssueComment) error {
	return s.Store.Delete(Schema.IssueComment.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *IssueCommentStore) Find(q *IssueCommentQuery) (*IssueCommentResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewIssueCommentResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *IssueCommentStore) MustFind(q *IssueCommentQuery) *IssueCommentResultSet {
	return NewIssueCommentResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *IssueCommentStore) Count(q *IssueCommentQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *IssueCommentStore) MustCount(q *IssueCommentQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *IssueCommentStore) FindOne(q *IssueCommentQuery) (*IssueComment, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *IssueCommentStore) FindAll(q *IssueCommentQuery) ([]*IssueComment, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *IssueCommentStore) MustFindOne(q *IssueCommentQuery) *IssueComment {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the IssueComment with the data in the database and
// makes it writable.
func (s *IssueCommentStore) Reload(record *IssueComment) error {
	return s.Store.Reload(Schema.IssueComment.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *IssueCommentStore) Transaction(callback func(*IssueCommentStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&IssueCommentStore{store})
	})
}

// IssueCommentQuery is the object used to create queries for the IssueComment
// entity.
type IssueCommentQuery struct {
	*kallax.BaseQuery
}

// NewIssueCommentQuery returns a new instance of IssueCommentQuery.
func NewIssueCommentQuery() *IssueCommentQuery {
	return &IssueCommentQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.IssueComment.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *IssueCommentQuery) Select(columns ...kallax.SchemaField) *IssueCommentQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *IssueCommentQuery) SelectNot(columns ...kallax.SchemaField) *IssueCommentQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *IssueCommentQuery) Copy() *IssueCommentQuery {
	return &IssueCommentQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *IssueCommentQuery) Order(cols ...kallax.ColumnOrder) *IssueCommentQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *IssueCommentQuery) BatchSize(size uint64) *IssueCommentQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *IssueCommentQuery) Limit(n uint64) *IssueCommentQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *IssueCommentQuery) Offset(n uint64) *IssueCommentQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *IssueCommentQuery) Where(cond kallax.Condition) *IssueCommentQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *IssueCommentQuery) FindByKallaxID(v ...int64) *IssueCommentQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.IssueComment.KallaxID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *IssueCommentQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *IssueCommentQuery {
	return q.Where(cond(Schema.IssueComment.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *IssueCommentQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *IssueCommentQuery {
	return q.Where(cond(Schema.IssueComment.UpdatedAt, v))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *IssueCommentQuery) FindByUserID(cond kallax.ScalarCond, v int64) *IssueCommentQuery {
	return q.Where(cond(Schema.IssueComment.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *IssueCommentQuery) FindByUserLogin(v string) *IssueCommentQuery {
	return q.Where(kallax.Eq(Schema.IssueComment.UserLogin, v))
}

// FindByIssueNumber adds a new filter to the query that will require that
// the IssueNumber property is equal to the passed value.
func (q *IssueCommentQuery) FindByIssueNumber(cond kallax.ScalarCond, v int) *IssueCommentQuery {
	return q.Where(cond(Schema.IssueComment.IssueNumber, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *IssueCommentQuery) FindByRepositoryOwner(v string) *IssueCommentQuery {
	return q.Where(kallax.Eq(Schema.IssueComment.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *IssueCommentQuery) FindByRepositoryName(v string) *IssueCommentQuery {
	return q.Where(kallax.Eq(Schema.IssueComment.RepositoryName, v))
}

// IssueCommentResultSet is the set of results returned by a query to the
// database.
type IssueCommentResultSet struct {
	ResultSet kallax.ResultSet
	last      *IssueComment
	lastErr   error
}

// NewIssueCommentResultSet creates a new result set for rows of the type
// IssueComment.
func NewIssueCommentResultSet(rs kallax.ResultSet) *IssueCommentResultSet {
	return &IssueCommentResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *IssueCommentResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.IssueComment.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*IssueComment)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *IssueComment")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *IssueCommentResultSet) Get() (*IssueComment, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *IssueCommentResultSet) ForEach(fn func(*IssueComment) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *IssueCommentResultSet) All() ([]*IssueComment, error) {
	var result []*IssueComment
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *IssueCommentResultSet) One() (*IssueComment, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *IssueCommentResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *IssueCommentResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewOrganization returns a new instance of Organization.
func NewOrganization() (record *Organization) {
	return new(Organization)
}

// GetID returns the primary key of the model.
func (r *Organization) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Organization) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "login":
		return types.Nullable(&r.Organization.Login), nil
	case "id":
		return types.Nullable(&r.Organization.ID), nil
	case "node_id":
		return types.Nullable(&r.Organization.NodeID), nil
	case "avatar_url":
		return types.Nullable(&r.Organization.AvatarURL), nil
	case "htmlurl":
		return types.Nullable(&r.Organization.HTMLURL), nil
	case "name":
		return types.Nullable(&r.Organization.Name), nil
	case "company":
		return types.Nullable(&r.Organization.Company), nil
	case "blog":
		return types.Nullable(&r.Organization.Blog), nil
	case "location":
		return types.Nullable(&r.Organization.Location), nil
	case "email":
		return types.Nullable(&r.Organization.Email), nil
	case "description":
		return types.Nullable(&r.Organization.Description), nil
	case "public_repos":
		return types.Nullable(&r.Organization.PublicRepos), nil
	case "public_gists":
		return types.Nullable(&r.Organization.PublicGists), nil
	case "followers":
		return types.Nullable(&r.Organization.Followers), nil
	case "following":
		return types.Nullable(&r.Organization.Following), nil
	case "created_at":
		return types.Nullable(&r.Organization.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.Organization.UpdatedAt), nil
	case "total_private_repos":
		return types.Nullable(&r.Organization.TotalPrivateRepos), nil
	case "owned_private_repos":
		return types.Nullable(&r.Organization.OwnedPrivateRepos), nil
	case "private_gists":
		return types.Nullable(&r.Organization.PrivateGists), nil
	case "disk_usage":
		return types.Nullable(&r.Organization.DiskUsage), nil
	case "collaborators":
		return types.Nullable(&r.Organization.Collaborators), nil
	case "billing_email":
		return types.Nullable(&r.Organization.BillingEmail), nil
	case "type":
		return types.Nullable(&r.Organization.Type), nil
	case "two_factor_requirement_enabled":
		return types.Nullable(&r.Organization.TwoFactorRequirementEnabled), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organization: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Organization) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "login":
		if r.Organization.Login == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Login, nil
	case "id":
		if r.Organization.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.Organization.ID, nil
	case "node_id":
		if r.Organization.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.NodeID, nil
	case "avatar_url":
		if r.Organization.AvatarURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.AvatarURL, nil
	case "htmlurl":
		if r.Organization.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.HTMLURL, nil
	case "name":
		if r.Organization.Name == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Name, nil
	case "company":
		if r.Organization.Company == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Company, nil
	case "blog":
		if r.Organization.Blog == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Blog, nil
	case "location":
		if r.Organization.Location == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Location, nil
	case "email":
		if r.Organization.Email == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Email, nil
	case "description":
		if r.Organization.Description == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Description, nil
	case "public_repos":
		if r.Organization.PublicRepos == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.PublicRepos, nil
	case "public_gists":
		if r.Organization.PublicGists == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.PublicGists, nil
	case "followers":
		if r.Organization.Followers == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.Followers, nil
	case "following":
		if r.Organization.Following == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.Following, nil
	case "created_at":
		if r.Organization.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Organization.CreatedAt, nil
	case "updated_at":
		if r.Organization.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Organization.UpdatedAt, nil
	case "total_private_repos":
		if r.Organization.TotalPrivateRepos == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.TotalPrivateRepos, nil
	case "owned_private_repos":
		if r.Organization.OwnedPrivateRepos == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.OwnedPrivateRepos, nil
	case "private_gists":
		if r.Organization.PrivateGists == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.PrivateGists, nil
	case "disk_usage":
		if r.Organization.DiskUsage == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.DiskUsage, nil
	case "collaborators":
		if r.Organization.Collaborators == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.Collaborators, nil
	case "billing_email":
		if r.Organization.BillingEmail == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.BillingEmail, nil
	case "type":
		if r.Organization.Type == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Type, nil
	case "two_factor_requirement_enabled":
		if r.Organization.TwoFactorRequirementEnabled == (*bool)(nil) {
			return nil, nil
		}
		return r.Organization.TwoFactorRequirementEnabled, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organization: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Organization) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Organization has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Organization) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Organization has no relationships")
}

// OrganizationStore is the entity to access the records of the type Organization
// in the database.
type OrganizationStore struct {
	*kallax.Store
}

// NewOrganizationStore creates a new instance of OrganizationStore
// using a SQL database.
func NewOrganizationStore(db *sql.DB) *OrganizationStore {
	return &OrganizationStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *OrganizationStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *OrganizationStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *OrganizationStore) Debug() *OrganizationStore {
	return &OrganizationStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *OrganizationStore) DebugWith(logger kallax.LoggerFunc) *OrganizationStore {
	return &OrganizationStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *OrganizationStore) DisableCacher() *OrganizationStore {
	return &OrganizationStore{s.Store.DisableCacher()}
}

// Insert inserts a Organization in the database. A non-persisted object is
// required for this operation.
func (s *OrganizationStore) Insert(record *Organization) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Organization.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *OrganizationStore) Update(record *Organization, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Organization.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *OrganizationStore) Save(record *Organization) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *OrganizationStore) Delete(record *Organization) error {
	return s.Store.Delete(Schema.Organization.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *OrganizationStore) Find(q *OrganizationQuery) (*OrganizationResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewOrganizationResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *OrganizationStore) MustFind(q *OrganizationQuery) *OrganizationResultSet {
	return NewOrganizationResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *OrganizationStore) Count(q *OrganizationQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *OrganizationStore) MustCount(q *OrganizationQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *OrganizationStore) FindOne(q *OrganizationQuery) (*Organization, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *OrganizationStore) FindAll(q *OrganizationQuery) ([]*Organization, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *OrganizationStore) MustFindOne(q *OrganizationQuery) *Organization {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Organization with the data in the database and
// makes it writable.
func (s *OrganizationStore) Reload(record *Organization) error {
	return s.Store.Reload(Schema.Organization.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *OrganizationStore) Transaction(callback func(*OrganizationStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&OrganizationStore{store})
	})
}

// OrganizationQuery is the object used to create queries for the Organization
// entity.
type OrganizationQuery struct {
	*kallax.BaseQuery
}

// NewOrganizationQuery returns a new instance of OrganizationQuery.
func NewOrganizationQuery() *OrganizationQuery {
	return &OrganizationQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Organization.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *OrganizationQuery) Select(columns ...kallax.SchemaField) *OrganizationQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *OrganizationQuery) SelectNot(columns ...kallax.SchemaField) *OrganizationQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *OrganizationQuery) Copy() *OrganizationQuery {
	return &OrganizationQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *OrganizationQuery) Order(cols ...kallax.ColumnOrder) *OrganizationQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *OrganizationQuery) BatchSize(size uint64) *OrganizationQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *OrganizationQuery) Limit(n uint64) *OrganizationQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *OrganizationQuery) Offset(n uint64) *OrganizationQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *OrganizationQuery) Where(cond kallax.Condition) *OrganizationQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *OrganizationQuery) FindByKallaxID(v ...int64) *OrganizationQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Organization.KallaxID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *OrganizationQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *OrganizationQuery {
	return q.Where(cond(Schema.Organization.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *OrganizationQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *OrganizationQuery {
	return q.Where(cond(Schema.Organization.UpdatedAt, v))
}

// OrganizationResultSet is the set of results returned by a query to the
// database.
type OrganizationResultSet struct {
	ResultSet kallax.ResultSet
	last      *Organization
	lastErr   error
}

// NewOrganizationResultSet creates a new result set for rows of the type
// Organization.
func NewOrganizationResultSet(rs kallax.ResultSet) *OrganizationResultSet {
	return &OrganizationResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *OrganizationResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Organization.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Organization)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Organization")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *OrganizationResultSet) Get() (*Organization, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *OrganizationResultSet) ForEach(fn func(*Organization) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *OrganizationResultSet) All() ([]*Organization, error) {
	var result []*Organization
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *OrganizationResultSet) One() (*Organization, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *OrganizationResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *OrganizationResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPullRequest returns a new instance of PullRequest.
func NewPullRequest() (record *PullRequest) {
	return new(PullRequest)
}

// GetID returns the primary key of the model.
func (r *PullRequest) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PullRequest) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "id":
		return types.Nullable(&r.PullRequest.ID), nil
	case "number":
		return types.Nullable(&r.PullRequest.Number), nil
	case "state":
		return types.Nullable(&r.PullRequest.State), nil
	case "title":
		return types.Nullable(&r.PullRequest.Title), nil
	case "body":
		return types.Nullable(&r.PullRequest.Body), nil
	case "created_at":
		return types.Nullable(&r.PullRequest.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.PullRequest.UpdatedAt), nil
	case "closed_at":
		return types.Nullable(&r.PullRequest.ClosedAt), nil
	case "merged_at":
		return types.Nullable(&r.PullRequest.MergedAt), nil
	case "draft":
		return types.Nullable(&r.PullRequest.Draft), nil
	case "merged":
		return types.Nullable(&r.PullRequest.Merged), nil
	case "mergeable":
		return types.Nullable(&r.PullRequest.Mergeable), nil
	case "mergeable_state":
		return types.Nullable(&r.PullRequest.MergeableState), nil
	case "merge_commit_sha":
		return types.Nullable(&r.PullRequest.MergeCommitSHA), nil
	case "comments":
		return types.Nullable(&r.PullRequest.Comments), nil
	case "commits":
		return types.Nullable(&r.PullRequest.Commits), nil
	case "additions":
		return types.Nullable(&r.PullRequest.Additions), nil
	case "deletions":
		return types.Nullable(&r.PullRequest.Deletions), nil
	case "changed_files":
		return types.Nullable(&r.PullRequest.ChangedFiles), nil
	case "htmlurl":
		return types.Nullable(&r.PullRequest.HTMLURL), nil
	case "review_comments":
		return types.Nullable(&r.PullRequest.ReviewComments), nil
	case "maintainer_can_modify":
		return types.Nullable(&r.PullRequest.MaintainerCanModify), nil
	case "author_association":
		return types.Nullable(&r.PullRequest.AuthorAssociation), nil
	case "node_id":
		return types.Nullable(&r.PullRequest.NodeID), nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil
	case "labels":
		return types.Slice(&r.LabelList), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "merged_by_id":
		return &r.MergedByID, nil
	case "merged_by_login":
		return &r.MergedByLogin, nil
	case "assignee_id":
		return &r.AssigneeID, nil
	case "assignee_login":
		return &r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(&r.AssigneesList), nil
	case "requested_reviewers":
		return types.JSON(&r.RequestedReviewersList), nil
	case "milestone_id":
		return &r.MilestoneID, nil
	case "milestone_title":
		return &r.MilestoneTitle, nil
	case "head_sha":
		return &r.HeadSHA, nil
	case "head_ref":
		return &r.HeadRef, nil
	case "head_label":
		return &r.HeadLabel, nil
	case "head_user":
		return &r.HeadUser, nil
	case "head_repository_owner":
		return &r.HeadRepositoryOwner, nil
	case "head_repository_name":
		return &r.HeadRepositoryName, nil
	case "base_sha":
		return &r.BaseSHA, nil
	case "base_ref":
		return &r.BaseRef, nil
	case "base_label":
		return &r.BaseLabel, nil
	case "base_user":
		return &r.BaseUser, nil
	case "base_repository_owner":
		return &r.BaseRepositoryOwner, nil
	case "base_repository_name":
		return &r.BaseRepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequest: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PullRequest) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "id":
		if r.PullRequest.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.PullRequest.ID, nil
	case "number":
		if r.PullRequest.Number == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Number, nil
	case "state":
		if r.PullRequest.State == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.State, nil
	case "title":
		if r.PullRequest.Title == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.Title, nil
	case "body":
		if r.PullRequest.Body == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.Body, nil
	case "created_at":
		if r.PullRequest.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.CreatedAt, nil
	case "updated_at":
		if r.PullRequest.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.UpdatedAt, nil
	case "closed_at":
		if r.PullRequest.ClosedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.ClosedAt, nil
	case "merged_at":
		if r.PullRequest.MergedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.MergedAt, nil
	case "draft":
		if r.PullRequest.Draft == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.Draft, nil
	case "merged":
		if r.PullRequest.Merged == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.Merged, nil
	case "mergeable":
		if r.PullRequest.Mergeable == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.Mergeable, nil
	case "mergeable_state":
		if r.PullRequest.MergeableState == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.MergeableState, nil
	case "merge_commit_sha":
		if r.PullRequest.MergeCommitSHA == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.MergeCommitSHA, nil
	case "comments":
		if r.PullRequest.Comments == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Comments, nil
	case "commits":
		if r.PullRequest.Commits == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Commits, nil
	case "additions":
		if r.PullRequest.Additions == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Additions, nil
	case "deletions":
		if r.PullRequest.Deletions == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Deletions, nil
	case "changed_files":
		if r.PullRequest.ChangedFiles == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.ChangedFiles, nil
	case "htmlurl":
		if r.PullRequest.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.HTMLURL, nil
	case "review_comments":
		if r.PullRequest.ReviewComments == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.ReviewComments, nil
	case "maintainer_can_modify":
		if r.PullRequest.MaintainerCanModify == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.MaintainerCanModify, nil
	case "author_association":
		if r.PullRequest.AuthorAssociation == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.AuthorAssociation, nil
	case "node_id":
		if r.PullRequest.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.NodeID, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil
	case "labels":
		return types.Slice(r.LabelList), nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "merged_by_id":
		return r.MergedByID, nil
	case "merged_by_login":
		return r.MergedByLogin, nil
	case "assignee_id":
		return r.AssigneeID, nil
	case "assignee_login":
		return r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(r.AssigneesList), nil
	case "requested_reviewers":
		return types.JSON(r.RequestedReviewersList), nil
	case "milestone_id":
		return r.MilestoneID, nil
	case "milestone_title":
		return r.MilestoneTitle, nil
	case "head_sha":
		return r.HeadSHA, nil
	case "head_ref":
		return r.HeadRef, nil
	case "head_label":
		return r.HeadLabel, nil
	case "head_user":
		return r.HeadUser, nil
	case "head_repository_owner":
		return r.HeadRepositoryOwner, nil
	case "head_repository_name":
		return r.HeadRepositoryName, nil
	case "base_sha":
		return r.BaseSHA, nil
	case "base_ref":
		return r.BaseRef, nil
	case "base_label":
		return r.BaseLabel, nil
	case "base_user":
		return r.BaseUser, nil
	case "base_repository_owner":
		return r.BaseRepositoryOwner, nil
	case "base_repository_name":
		return r.BaseRepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequest: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PullRequest) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model PullRequest has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *PullRequest) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model PullRequest has no relationships")
}

// PullRequestStore is the entity to access the records of the type PullRequest
// in the database.
type PullRequestStore struct {
	*kallax.Store
}

// NewPullRequestStore creates a new instance of PullRequestStore
// using a SQL database.
func NewPullRequestStore(db *sql.DB) *PullRequestStore {
	return &PullRequestStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PullRequestStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PullRequestStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PullRequestStore) Debug() *PullRequestStore {
	return &PullRequestStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PullRequestStore) DebugWith(logger kallax.LoggerFunc) *PullRequestStore {
	return &PullRequestStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PullRequestStore) DisableCacher() *PullRequestStore {
	return &PullRequestStore{s.Store.DisableCacher()}
}

// Insert inserts a PullRequest in the database. A non-persisted object is
// required for this operation.
func (s *PullRequestStore) Insert(record *PullRequest) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}
	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.MergedAt != nil {
		record.MergedAt = func(t time.Time) *time.Time { return &t }(record.MergedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.PullRequest.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PullRequestStore) Update(record *PullRequest, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}
	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.MergedAt != nil {
		record.MergedAt = func(t time.Time) *time.Time { return &t }(record.MergedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.PullRequest.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PullRequestStore) Save(record *PullRequest) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PullRequestStore) Delete(record *PullRequest) error {
	return s.Store.Delete(Schema.PullRequest.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PullRequestStore) Find(q *PullRequestQuery) (*PullRequestResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPullRequestResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PullRequestStore) MustFind(q *PullRequestQuery) *PullRequestResultSet {
	return NewPullRequestResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PullRequestStore) Count(q *PullRequestQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PullRequestStore) MustCount(q *PullRequestQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PullRequestStore) FindOne(q *PullRequestQuery) (*PullRequest, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PullRequestStore) FindAll(q *PullRequestQuery) ([]*PullRequest, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PullRequestStore) MustFindOne(q *PullRequestQuery) *PullRequest {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PullRequest with the data in the database and
// makes it writable.
func (s *PullRequestStore) Reload(record *PullRequest) error {
	return s.Store.Reload(Schema.PullRequest.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PullRequestStore) Transaction(callback func(*PullRequestStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PullRequestStore{store})
	})
}

// PullRequestQuery is the object used to create queries for the PullRequest
// entity.
type PullRequestQuery struct {
	*kallax.BaseQuery
}

// NewPullRequestQuery returns a new instance of PullRequestQuery.
func NewPullRequestQuery() *PullRequestQuery {
	return &PullRequestQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PullRequest.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PullRequestQuery) Select(columns ...kallax.SchemaField) *PullRequestQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PullRequestQuery) SelectNot(columns ...kallax.SchemaField) *PullRequestQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PullRequestQuery) Copy() *PullRequestQuery {
	return &PullRequestQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PullRequestQuery) Order(cols ...kallax.ColumnOrder) *PullRequestQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PullRequestQuery) BatchSize(size uint64) *PullRequestQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PullRequestQuery) Limit(n uint64) *PullRequestQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PullRequestQuery) Offset(n uint64) *PullRequestQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PullRequestQuery) Where(cond kallax.Condition) *PullRequestQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PullRequestQuery) FindByKallaxID(v ...int64) *PullRequestQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.PullRequest.KallaxID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.UpdatedAt, v))
}

// FindByClosedAt adds a new filter to the query that will require that
// the ClosedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByClosedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.ClosedAt, v))
}

// FindByMergedAt adds a new filter to the query that will require that
// the MergedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByMergedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.MergedAt, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *PullRequestQuery) FindByRepositoryOwner(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *PullRequestQuery) FindByRepositoryName(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.RepositoryName, v))
}

// FindByLabelList adds a new filter to the query that will require that
// the LabelList property contains all the passed values; if no passed values,
// it will do nothing.
func (q *PullRequestQuery) FindByLabelList(v ...string) *PullRequestQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.PullRequest.LabelList, values...))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *PullRequestQuery) FindByUserID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *PullRequestQuery) FindByUserLogin(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.UserLogin, v))
}

// FindByMergedByID adds a new filter to the query that will require that
// the MergedByID property is equal to the passed value.
func (q *PullRequestQuery) FindByMergedByID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.MergedByID, v))
}

// FindByMergedByLogin adds a new filter to the query that will require that
// the MergedByLogin property is equal to the passed value.
func (q *PullRequestQuery) FindByMergedByLogin(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.MergedByLogin, v))
}

// FindByAssigneeID adds a new filter to the query that will require that
// the AssigneeID property is equal to the passed value.
func (q *PullRequestQuery) FindByAssigneeID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.AssigneeID, v))
}

// FindByAssigneeLogin adds a new filter to the query that will require that
// the AssigneeLogin property is equal to the passed value.
func (q *PullRequestQuery) FindByAssigneeLogin(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.AssigneeLogin, v))
}

// FindByMilestoneID adds a new filter to the query that will require that
// the MilestoneID property is equal to the passed value.
func (q *PullRequestQuery) FindByMilestoneID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.MilestoneID, v))
}

// FindByMilestoneTitle adds a new filter to the query that will require that
// the MilestoneTitle property is equal to the passed value.
func (q *PullRequestQuery) FindByMilestoneTitle(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.MilestoneTitle, v))
}

// FindByHeadSHA adds a new filter to the query that will require that
// the HeadSHA property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadSHA(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadSHA, v))
}

// FindByHeadRef adds a new filter to the query that will require that
// the HeadRef property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadRef(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadRef, v))
}

// FindByHeadLabel adds a new filter to the query that will require that
// the HeadLabel property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadLabel(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadLabel, v))
}

// FindByHeadUser adds a new filter to the query that will require that
// the HeadUser property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadUser(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadUser, v))
}

// FindByHeadRepositoryOwner adds a new filter to the query that will require that
// the HeadRepositoryOwner property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadRepositoryOwner(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadRepositoryOwner, v))
}

// FindByHeadRepositoryName adds a new filter to the query that will require that
// the HeadRepositoryName property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadRepositoryName(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadRepositoryName, v))
}

// FindByBaseSHA adds a new filter to the query that will require that
// the BaseSHA property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseSHA(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseSHA, v))
}

// FindByBaseRef adds a new filter to the query that will require that
// the BaseRef property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseRef(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseRef, v))
}

// FindByBaseLabel adds a new filter to the query that will require that
// the BaseLabel property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseLabel(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseLabel, v))
}

// FindByBaseUser adds a new filter to the query that will require that
// the BaseUser property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseUser(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseUser, v))
}

// FindByBaseRepositoryOwner adds a new filter to the query that will require that
// the BaseRepositoryOwner property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseRepositoryOwner(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseRepositoryOwner, v))
}

// FindByBaseRepositoryName adds a new filter to the query that will require that
// the BaseRepositoryName property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseRepositoryName(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseRepositoryName, v))
}

// PullRequestResultSet is the set of results returned by a query to the
// database.
type PullRequestResultSet struct {
	ResultSet kallax.ResultSet
	last      *PullRequest
	lastErr   error
}

// NewPullRequestResultSet creates a new result set for rows of the type
// PullRequest.
func NewPullRequestResultSet(rs kallax.ResultSet) *PullRequestResultSet {
	return &PullRequestResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PullRequestResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PullRequest.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PullRequest)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PullRequest")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PullRequestResultSet) Get() (*PullRequest, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PullRequestResultSet) ForEach(fn func(*PullRequest) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PullRequestResultSet) All() ([]*PullRequest, error) {
	var result []*PullRequest
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PullRequestResultSet) One() (*PullRequest, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PullRequestResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PullRequestResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPullRequestComment returns a new instance of PullRequestComment.
func NewPullRequestComment() (record *PullRequestComment) {
	return new(PullRequestComment)
}

// GetID returns the primary key of the model.
func (r *PullRequestComment) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PullRequestComment) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "id":
		return types.Nullable(&r.PullRequestComment.ID), nil
	case "node_id":
		return types.Nullable(&r.PullRequestComment.NodeID), nil
	case "in_reply_to":
		return types.Nullable(&r.PullRequestComment.InReplyTo), nil
	case "body":
		return types.Nullable(&r.PullRequestComment.Body), nil
	case "path":
		return types.Nullable(&r.PullRequestComment.Path), nil
	case "diff_hunk":
		return types.Nullable(&r.PullRequestComment.DiffHunk), nil
	case "pull_request_review_id":
		return types.Nullable(&r.PullRequestComment.PullRequestReviewID), nil
	case "position":
		return types.Nullable(&r.PullRequestComment.Position), nil
	case "original_position":
		return types.Nullable(&r.PullRequestComment.OriginalPosition), nil
	case "commit_id":
		return types.Nullable(&r.PullRequestComment.CommitID), nil
	case "original_commit_id":
		return types.Nullable(&r.PullRequestComment.OriginalCommitID), nil
	case "reactions":
		if r.Reactions == nil {
			r.Reactions = new(github.Reactions)
		}
		return types.JSON(r.PullRequestComment.Reactions), nil
	case "created_at":
		return types.Nullable(&r.PullRequestComment.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.PullRequestComment.UpdatedAt), nil
	case "author_association":
		return types.Nullable(&r.PullRequestComment.AuthorAssociation), nil
	case "htmlurl":
		return types.Nullable(&r.PullRequestComment.HTMLURL), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "pull_request_number":
		return &r.PullRequestNumber, nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequestComment: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PullRequestComment) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "id":
		if r.PullRequestComment.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.ID, nil
	case "node_id":
		if r.PullRequestComment.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.NodeID, nil
	case "in_reply_to":
		if r.PullRequestComment.InReplyTo == (*int64)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.InReplyTo, nil
	case "body":
		if r.PullRequestComment.Body == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.Body, nil
	case "path":
		if r.PullRequestComment.Path == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.Path, nil
	case "diff_hunk":
		if r.PullRequestComment.DiffHunk == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.DiffHunk, nil
	case "pull_request_review_id":
		if r.PullRequestComment.PullRequestReviewID == (*int64)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.PullRequestReviewID, nil
	case "position":
		if r.PullRequestComment.Position == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.Position, nil
	case "original_position":
		if r.PullRequestComment.OriginalPosition == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.OriginalPosition, nil
	case "commit_id":
		if r.PullRequestComment.CommitID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.CommitID, nil
	case "original_commit_id":
		if r.PullRequestComment.OriginalCommitID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.OriginalCommitID, nil
	case "reactions":
		if r.PullRequestComment.Reactions == (*github.Reactions)(nil) {
			return nil, nil
		}
		return types.JSON(r.PullRequestComment.Reactions), nil
	case "created_at":
		if r.PullRequestComment.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.CreatedAt, nil
	case "updated_at":
		if r.PullRequestComment.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.UpdatedAt, nil
	case "author_association":
		if r.PullRequestComment.AuthorAssociation == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.AuthorAssociation, nil
	case "htmlurl":
		if r.PullRequestComment.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestComment.HTMLURL, nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "pull_request_number":
		return r.PullRequestNumber, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequestComment: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PullRequestComment) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model PullRequestComment has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *PullRequestComment) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model PullRequestComment has no relationships")
}

// PullRequestCommentStore is the entity to access the records of the type PullRequestComment
// in the database.
type PullRequestCommentStore struct {
	*kallax.Store
}

// NewPullRequestCommentStore creates a new instance of PullRequestCommentStore
// using a SQL database.
func NewPullRequestCommentStore(db *sql.DB) *PullRequestCommentStore {
	return &PullRequestCommentStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PullRequestCommentStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PullRequestCommentStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PullRequestCommentStore) Debug() *PullRequestCommentStore {
	return &PullRequestCommentStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PullRequestCommentStore) DebugWith(logger kallax.LoggerFunc) *PullRequestCommentStore {
	return &PullRequestCommentStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PullRequestCommentStore) DisableCacher() *PullRequestCommentStore {
	return &PullRequestCommentStore{s.Store.DisableCacher()}
}

// Insert inserts a PullRequestComment in the database. A non-persisted object is
// required for this operation.
func (s *PullRequestCommentStore) Insert(record *PullRequestComment) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.PullRequestComment.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PullRequestCommentStore) Update(record *PullRequestComment, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.PullRequestComment.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PullRequestCommentStore) Save(record *PullRequestComment) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PullRequestCommentStore) Delete(record *PullRequestComment) error {
	return s.Store.Delete(Schema.PullRequestComment.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PullRequestCommentStore) Find(q *PullRequestCommentQuery) (*PullRequestCommentResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPullRequestCommentResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PullRequestCommentStore) MustFind(q *PullRequestCommentQuery) *PullRequestCommentResultSet {
	return NewPullRequestCommentResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PullRequestCommentStore) Count(q *PullRequestCommentQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PullRequestCommentStore) MustCount(q *PullRequestCommentQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PullRequestCommentStore) FindOne(q *PullRequestCommentQuery) (*PullRequestComment, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PullRequestCommentStore) FindAll(q *PullRequestCommentQuery) ([]*PullRequestComment, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PullRequestCommentStore) MustFindOne(q *PullRequestCommentQuery) *PullRequestComment {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PullRequestComment with the data in the database and
// makes it writable.
func (s *PullRequestCommentStore) Reload(record *PullRequestComment) error {
	return s.Store.Reload(Schema.PullRequestComment.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PullRequestCommentStore) Transaction(callback func(*PullRequestCommentStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PullRequestCommentStore{store})
	})
}

// PullRequestCommentQuery is the object used to create queries for the PullRequestComment
// entity.
type PullRequestCommentQuery struct {
	*kallax.BaseQuery
}

// NewPullRequestCommentQuery returns a new instance of PullRequestCommentQuery.
func NewPullRequestCommentQuery() *PullRequestCommentQuery {
	return &PullRequestCommentQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PullRequestComment.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PullRequestCommentQuery) Select(columns ...kallax.SchemaField) *PullRequestCommentQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PullRequestCommentQuery) SelectNot(columns ...kallax.SchemaField) *PullRequestCommentQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PullRequestCommentQuery) Copy() *PullRequestCommentQuery {
	return &PullRequestCommentQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PullRequestCommentQuery) Order(cols ...kallax.ColumnOrder) *PullRequestCommentQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PullRequestCommentQuery) BatchSize(size uint64) *PullRequestCommentQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PullRequestCommentQuery) Limit(n uint64) *PullRequestCommentQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PullRequestCommentQuery) Offset(n uint64) *PullRequestCommentQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PullRequestCommentQuery) Where(cond kallax.Condition) *PullRequestCommentQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PullRequestCommentQuery) FindByKallaxID(v ...int64) *PullRequestCommentQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.PullRequestComment.KallaxID, values...))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *PullRequestCommentQuery {
	return q.Where(cond(Schema.PullRequestComment.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *PullRequestCommentQuery {
	return q.Where(cond(Schema.PullRequestComment.UpdatedAt, v))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByUserID(cond kallax.ScalarCond, v int64) *PullRequestCommentQuery {
	return q.Where(cond(Schema.PullRequestComment.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByUserLogin(v string) *PullRequestCommentQuery {
	return q.Where(kallax.Eq(Schema.PullRequestComment.UserLogin, v))
}

// FindByPullRequestNumber adds a new filter to the query that will require that
// the PullRequestNumber property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByPullRequestNumber(cond kallax.ScalarCond, v int) *PullRequestCommentQuery {
	return q.Where(cond(Schema.PullRequestComment.PullRequestNumber, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByRepositoryOwner(v string) *PullRequestCommentQuery {
	return q.Where(kallax.Eq(Schema.PullRequestComment.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *PullRequestCommentQuery) FindByRepositoryName(v string) *PullRequestCommentQuery {
	return q.Where(kallax.Eq(Schema.PullRequestComment.RepositoryName, v))
}

// PullRequestCommentResultSet is the set of results returned by a query to the
// database.
type PullRequestCommentResultSet struct {
	ResultSet kallax.ResultSet
	last      *PullRequestComment
	lastErr   error
}

// NewPullRequestCommentResultSet creates a new result set for rows of the type
// PullRequestComment.
func NewPullRequestCommentResultSet(rs kallax.ResultSet) *PullRequestCommentResultSet {
	return &PullRequestCommentResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PullRequestCommentResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PullRequestComment.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PullRequestComment)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PullRequestComment")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PullRequestCommentResultSet) Get() (*PullRequestComment, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PullRequestCommentResultSet) ForEach(fn func(*PullRequestComment) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PullRequestCommentResultSet) All() ([]*PullRequestComment, error) {
	var result []*PullRequestComment
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PullRequestCommentResultSet) One() (*PullRequestComment, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PullRequestCommentResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PullRequestCommentResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPullRequestReview returns a new instance of PullRequestReview.
func NewPullRequestReview() (record *PullRequestReview) {
	return new(PullRequestReview)
}

// GetID returns the primary key of the model.
func (r *PullRequestReview) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PullRequestReview) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "id":
		return types.Nullable(&r.PullRequestReview.ID), nil
	case "node_id":
		return types.Nullable(&r.PullRequestReview.NodeID), nil
	case "body":
		return types.Nullable(&r.PullRequestReview.Body), nil
	case "submitted_at":
		return types.Nullable(&r.PullRequestReview.SubmittedAt), nil
	case "commit_id":
		return types.Nullable(&r.PullRequestReview.CommitID), nil
	case "htmlurl":
		return types.Nullable(&r.PullRequestReview.HTMLURL), nil
	case "state":
		return types.Nullable(&r.PullRequestReview.State), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "pull_request_number":
		return &r.PullRequestNumber, nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequestReview: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PullRequestReview) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "id":
		if r.PullRequestReview.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.ID, nil
	case "node_id":
		if r.PullRequestReview.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.NodeID, nil
	case "body":
		if r.PullRequestReview.Body == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.Body, nil
	case "submitted_at":
		if r.PullRequestReview.SubmittedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.SubmittedAt, nil
	case "commit_id":
		if r.PullRequestReview.CommitID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.CommitID, nil
	case "htmlurl":
		if r.PullRequestReview.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.HTMLURL, nil
	case "state":
		if r.PullRequestReview.State == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequestReview.State, nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "pull_request_number":
		return r.PullRequestNumber, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequestReview: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PullRequestReview) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model PullRequestReview has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *PullRequestReview) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model PullRequestReview has no relationships")
}

// PullRequestReviewStore is the entity to access the records of the type PullRequestReview
// in the database.
type PullRequestReviewStore struct {
	*kallax.Store
}

// NewPullRequestReviewStore creates a new instance of PullRequestReviewStore
// using a SQL database.
func NewPullRequestReviewStore(db *sql.DB) *PullRequestReviewStore {
	return &PullRequestReviewStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PullRequestReviewStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PullRequestReviewStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PullRequestReviewStore) Debug() *PullRequestReviewStore {
	return &PullRequestReviewStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PullRequestReviewStore) DebugWith(logger kallax.LoggerFunc) *PullRequestReviewStore {
	return &PullRequestReviewStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PullRequestReviewStore) DisableCacher() *PullRequestReviewStore {
	return &PullRequestReviewStore{s.Store.DisableCacher()}
}

// Insert inserts a PullRequestReview in the database. A non-persisted object is
// required for this operation.
func (s *PullRequestReviewStore) Insert(record *PullRequestReview) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.SubmittedAt != nil {
		record.SubmittedAt = func(t time.Time) *time.Time { return &t }(record.SubmittedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.PullRequestReview.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PullRequestReviewStore) Update(record *PullRequestReview, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.SubmittedAt != nil {
		record.SubmittedAt = func(t time.Time) *time.Time { return &t }(record.SubmittedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.PullRequestReview.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PullRequestReviewStore) Save(record *PullRequestReview) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PullRequestReviewStore) Delete(record *PullRequestReview) error {
	return s.Store.Delete(Schema.PullRequestReview.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PullRequestReviewStore) Find(q *PullRequestReviewQuery) (*PullRequestReviewResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPullRequestReviewResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PullRequestReviewStore) MustFind(q *PullRequestReviewQuery) *PullRequestReviewResultSet {
	return NewPullRequestReviewResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PullRequestReviewStore) Count(q *PullRequestReviewQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PullRequestReviewStore) MustCount(q *PullRequestReviewQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PullRequestReviewStore) FindOne(q *PullRequestReviewQuery) (*PullRequestReview, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PullRequestReviewStore) FindAll(q *PullRequestReviewQuery) ([]*PullRequestReview, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PullRequestReviewStore) MustFindOne(q *PullRequestReviewQuery) *PullRequestReview {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PullRequestReview with the data in the database and
// makes it writable.
func (s *PullRequestReviewStore) Reload(record *PullRequestReview) error {
	return s.Store.Reload(Schema.PullRequestReview.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PullRequestReviewStore) Transaction(callback func(*PullRequestReviewStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PullRequestReviewStore{store})
	})
}

// PullRequestReviewQuery is the object used to create queries for the PullRequestReview
// entity.
type PullRequestReviewQuery struct {
	*kallax.BaseQuery
}

// NewPullRequestReviewQuery returns a new instance of PullRequestReviewQuery.
func NewPullRequestReviewQuery() *PullRequestReviewQuery {
	return &PullRequestReviewQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PullRequestReview.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PullRequestReviewQuery) Select(columns ...kallax.SchemaField) *PullRequestReviewQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PullRequestReviewQuery) SelectNot(columns ...kallax.SchemaField) *PullRequestReviewQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PullRequestReviewQuery) Copy() *PullRequestReviewQuery {
	return &PullRequestReviewQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PullRequestReviewQuery) Order(cols ...kallax.ColumnOrder) *PullRequestReviewQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PullRequestReviewQuery) BatchSize(size uint64) *PullRequestReviewQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PullRequestReviewQuery) Limit(n uint64) *PullRequestReviewQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PullRequestReviewQuery) Offset(n uint64) *PullRequestReviewQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PullRequestReviewQuery) Where(cond kallax.Condition) *PullRequestReviewQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *PullRequestReviewQuery) FindByKallaxID(v ...int64) *PullRequestReviewQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.PullRequestReview.KallaxID, values...))
}

// FindBySubmittedAt adds a new filter to the query that will require that
// the SubmittedAt property is equal to the passed value.
func (q *PullRequestReviewQuery) FindBySubmittedAt(cond kallax.ScalarCond, v time.Time) *PullRequestReviewQuery {
	return q.Where(cond(Schema.PullRequestReview.SubmittedAt, v))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *PullRequestReviewQuery) FindByUserID(cond kallax.ScalarCond, v int64) *PullRequestReviewQuery {
	return q.Where(cond(Schema.PullRequestReview.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *PullRequestReviewQuery) FindByUserLogin(v string) *PullRequestReviewQuery {
	return q.Where(kallax.Eq(Schema.PullRequestReview.UserLogin, v))
}

// FindByPullRequestNumber adds a new filter to the query that will require that
// the PullRequestNumber property is equal to the passed value.
func (q *PullRequestReviewQuery) FindByPullRequestNumber(cond kallax.ScalarCond, v int) *PullRequestReviewQuery {
	return q.Where(cond(Schema.PullRequestReview.PullRequestNumber, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *PullRequestReviewQuery) FindByRepositoryOwner(v string) *PullRequestReviewQuery {
	return q.Where(kallax.Eq(Schema.PullRequestReview.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *PullRequestReviewQuery) FindByRepositoryName(v string) *PullRequestReviewQuery {
	return q.Where(kallax.Eq(Schema.PullRequestReview.RepositoryName, v))
}

// PullRequestReviewResultSet is the set of results returned by a query to the
// database.
type PullRequestReviewResultSet struct {
	ResultSet kallax.ResultSet
	last      *PullRequestReview
	lastErr   error
}

// NewPullRequestReviewResultSet creates a new result set for rows of the type
// PullRequestReview.
func NewPullRequestReviewResultSet(rs kallax.ResultSet) *PullRequestReviewResultSet {
	return &PullRequestReviewResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PullRequestReviewResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PullRequestReview.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PullRequestReview)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PullRequestReview")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PullRequestReviewResultSet) Get() (*PullRequestReview, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PullRequestReviewResultSet) ForEach(fn func(*PullRequestReview) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PullRequestReviewResultSet) All() ([]*PullRequestReview, error) {
	var result []*PullRequestReview
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PullRequestReviewResultSet) One() (*PullRequestReview, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PullRequestReviewResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PullRequestReviewResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewRepository returns a new instance of Repository.
func NewRepository() (record *Repository) {
	return new(Repository)
}

// GetID returns the primary key of the model.
func (r *Repository) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Repository) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "id":
		return types.Nullable(&r.Repository.ID), nil
	case "node_id":
		return types.Nullable(&r.Repository.NodeID), nil
	case "name":
		return types.Nullable(&r.Repository.Name), nil
	case "full_name":
		return types.Nullable(&r.Repository.FullName), nil
	case "description":
		return types.Nullable(&r.Repository.Description), nil
	case "homepage":
		return types.Nullable(&r.Repository.Homepage), nil
	case "code_of_conduct":
		if r.CodeOfConduct == nil {
			r.CodeOfConduct = new(github.CodeOfConduct)
		}
		return types.JSON(r.Repository.CodeOfConduct), nil
	case "default_branch":
		return types.Nullable(&r.Repository.DefaultBranch), nil
	case "master_branch":
		return types.Nullable(&r.Repository.MasterBranch), nil
	case "created_at":
		if r.CreatedAt == nil {
			r.CreatedAt = new(github.Timestamp)
		}
		return types.JSON(r.Repository.CreatedAt), nil
	case "pushed_at":
		if r.PushedAt == nil {
			r.PushedAt = new(github.Timestamp)
		}
		return types.JSON(r.Repository.PushedAt), nil
	case "updated_at":
		if r.UpdatedAt == nil {
			r.UpdatedAt = new(github.Timestamp)
		}
		return types.JSON(r.Repository.UpdatedAt), nil
	case "htmlurl":
		return types.Nullable(&r.Repository.HTMLURL), nil
	case "clone_url":
		return types.Nullable(&r.Repository.CloneURL), nil
	case "git_url":
		return types.Nullable(&r.Repository.GitURL), nil
	case "mirror_url":
		return types.Nullable(&r.Repository.MirrorURL), nil
	case "sshurl":
		return types.Nullable(&r.Repository.SSHURL), nil
	case "svnurl":
		return types.Nullable(&r.Repository.SVNURL), nil
	case "language":
		return types.Nullable(&r.Repository.Language), nil
	case "fork":
		return types.Nullable(&r.Repository.Fork), nil
	case "forks_count":
		return types.Nullable(&r.Repository.ForksCount), nil
	case "network_count":
		return types.Nullable(&r.Repository.NetworkCount), nil
	case "open_issues_count":
		return types.Nullable(&r.Repository.OpenIssuesCount), nil
	case "stargazers_count":
		return types.Nullable(&r.Repository.StargazersCount), nil
	case "subscribers_count":
		return types.Nullable(&r.Repository.SubscribersCount), nil
	case "watchers_count":
		return types.Nullable(&r.Repository.WatchersCount), nil
	case "size":
		return types.Nullable(&r.Repository.Size), nil
	case "auto_init":
		return types.Nullable(&r.Repository.AutoInit), nil
	case "permissions":
		if r.Permissions == nil {
			r.Permissions = new(map[string]bool)
		}
		return types.JSON(r.Repository.Permissions), nil
	case "allow_rebase_merge":
		return types.Nullable(&r.Repository.AllowRebaseMerge), nil
	case "allow_squash_merge":
		return types.Nullable(&r.Repository.AllowSquashMerge), nil
	case "allow_merge_commit":
		return types.Nullable(&r.Repository.AllowMergeCommit), nil
	case "topics":
		return types.Slice(&r.Repository.Topics), nil
	case "archived":
		return types.Nullable(&r.Repository.Archived), nil
	case "disabled":
		return types.Nullable(&r.Repository.Disabled), nil
	case "license":
		if r.License == nil {
			r.License = new(github.License)
		}
		return types.JSON(r.Repository.License), nil
	case "private":
		return types.Nullable(&r.Repository.Private), nil
	case "has_issues":
		return types.Nullable(&r.Repository.HasIssues), nil
	case "has_wiki":
		return types.Nullable(&r.Repository.HasWiki), nil
	case "has_pages":
		return types.Nullable(&r.Repository.HasPages), nil
	case "has_projects":
		return types.Nullable(&r.Repository.HasProjects), nil
	case "has_downloads":
		return types.Nullable(&r.Repository.HasDownloads), nil
	case "license_template":
		return types.Nullable(&r.Repository.LicenseTemplate), nil
	case "gitignore_template":
		return types.Nullable(&r.Repository.GitignoreTemplate), nil
	case "team_id":
		return types.Nullable(&r.Repository.TeamID), nil
	case "parent":
		if r.ParentRepository == nil {
			r.ParentRepository = new(RepositoryReference)
		}
		return types.JSON(r.ParentRepository), nil
	case "source":
		if r.SourceRepository == nil {
			r.SourceRepository = new(RepositoryReference)
		}
		return types.JSON(r.SourceRepository), nil
	case "owner_id":
		return &r.OwnerID, nil
	case "owner_type":
		return &r.OwnerType, nil
	case "owner_login":
		return &r.OwnerLogin, nil
	case "organization_id":
		return &r.OrganizationID, nil
	case "organization_name":
		return &r.OrganizationName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Repository: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Repository) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "id":
		if r.Repository.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.Repository.ID, nil
	case "node_id":
		if r.Repository.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.NodeID, nil
	case "name":
		if r.Repository.Name == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Name, nil
	case "full_name":
		if r.Repository.FullName == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.FullName, nil
	case "description":
		if r.Repository.Description == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Description, nil
	case "homepage":
		if r.Repository.Homepage == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Homepage, nil
	case "code_of_conduct":
		if r.Repository.CodeOfConduct == (*github.CodeOfConduct)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.CodeOfConduct), nil
	case "default_branch":
		if r.Repository.DefaultBranch == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.DefaultBranch, nil
	case "master_branch":
		if r.Repository.MasterBranch == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.MasterBranch, nil
	case "created_at":
		if r.Repository.CreatedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.CreatedAt), nil
	case "pushed_at":
		if r.Repository.PushedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.PushedAt), nil
	case "updated_at":
		if r.Repository.UpdatedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.UpdatedAt), nil
	case "htmlurl":
		if r.Repository.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.HTMLURL, nil
	case "clone_url":
		if r.Repository.CloneURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.CloneURL, nil
	case "git_url":
		if r.Repository.GitURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitURL, nil
	case "mirror_url":
		if r.Repository.MirrorURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.MirrorURL, nil
	case "sshurl":
		if r.Repository.SSHURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.SSHURL, nil
	case "svnurl":
		if r.Repository.SVNURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.SVNURL, nil
	case "language":
		if r.Repository.Language == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Language, nil
	case "fork":
		if r.Repository.Fork == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Fork, nil
	case "forks_count":
		if r.Repository.ForksCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.ForksCount, nil
	case "network_count":
		if r.Repository.NetworkCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.NetworkCount, nil
	case "open_issues_count":
		if r.Repository.OpenIssuesCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.OpenIssuesCount, nil
	case "stargazers_count":
		if r.Repository.StargazersCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.StargazersCount, nil
	case "subscribers_count":
		if r.Repository.SubscribersCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.SubscribersCount, nil
	case "watchers_count":
		if r.Repository.WatchersCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.WatchersCount, nil
	case "size":
		if r.Repository.Size == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.Size, nil
	case "auto_init":
		if r.Repository.AutoInit == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AutoInit, nil
	case "permissions":
		if r.Repository.Permissions == (*map[string]bool)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.Permissions), nil
	case "allow_rebase_merge":
		if r.Repository.AllowRebaseMerge == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AllowRebaseMerge, nil
	case "allow_squash_merge":
		if r.Repository.AllowSquashMerge == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AllowSquashMerge, nil
	case "allow_merge_commit":
		if r.Repository.AllowMergeCommit == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AllowMergeCommit, nil
	case "topics":
		return types.Slice(r.Repository.Topics), nil
	case "archived":
		if r.Repository.Archived == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Archived, nil
	case "disabled":
		if r.Repository.Disabled == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Disabled, nil
	case "license":
		if r.Repository.License == (*github.License)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.License), nil
	case "private":
		if r.Repository.Private == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Private, nil
	case "has_issues":
		if r.Repository.HasIssues == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasIssues, nil
	case "has_wiki":
		if r.Repository.HasWiki == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasWiki, nil
	case "has_pages":
		if r.Repository.HasPages == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasPages, nil
	case "has_projects":
		if r.Repository.HasProjects == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasProjects, nil
	case "has_downloads":
		if r.Repository.HasDownloads == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasDownloads, nil
	case "license_template":
		if r.Repository.LicenseTemplate == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.LicenseTemplate, nil
	case "gitignore_template":
		if r.Repository.GitignoreTemplate == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitignoreTemplate, nil
	case "team_id":
		if r.Repository.TeamID == (*int64)(nil) {
			return nil, nil
		}
		return r.Repository.TeamID, nil
	case "parent":
		if r.ParentRepository == (*RepositoryReference)(nil) {
			return nil, nil
		}
		return types.JSON(r.ParentRepository), nil
	case "source":
		if r.SourceRepository == (*RepositoryReference)(nil) {
			return nil, nil
		}
		return types.JSON(r.SourceRepository), nil
	case "owner_id":
		return r.OwnerID, nil
	case "owner_type":
		return r.OwnerType, nil
	case "owner_login":
		return r.OwnerLogin, nil
	case "organization_id":
		return r.OrganizationID, nil
	case "organization_name":
		return r.OrganizationName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Repository: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Repository) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Repository has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Repository) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Repository has no relationships")
}

// RepositoryStore is the entity to access the records of the type Repository
// in the database.
type RepositoryStore struct {
	*kallax.Store
}

// NewRepositoryStore creates a new instance of RepositoryStore
// using a SQL database.
func NewRepositoryStore(db *sql.DB) *RepositoryStore {
	return &RepositoryStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *RepositoryStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *RepositoryStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *RepositoryStore) Debug() *RepositoryStore {
	return &RepositoryStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *RepositoryStore) DebugWith(logger kallax.LoggerFunc) *RepositoryStore {
	return &RepositoryStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *RepositoryStore) DisableCacher() *RepositoryStore {
	return &RepositoryStore{s.Store.DisableCacher()}
}

// Insert inserts a Repository in the database. A non-persisted object is
// required for this operation.
func (s *RepositoryStore) Insert(record *Repository) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Repository.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *RepositoryStore) Update(record *Repository, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Repository.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *RepositoryStore) Save(record *Repository) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *RepositoryStore) Delete(record *Repository) error {
	return s.Store.Delete(Schema.Repository.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *RepositoryStore) Find(q *RepositoryQuery) (*RepositoryResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewRepositoryResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *RepositoryStore) MustFind(q *RepositoryQuery) *RepositoryResultSet {
	return NewRepositoryResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *RepositoryStore) Count(q *RepositoryQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *RepositoryStore) MustCount(q *RepositoryQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *RepositoryStore) FindOne(q *RepositoryQuery) (*Repository, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *RepositoryStore) FindAll(q *RepositoryQuery) ([]*Repository, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *RepositoryStore) MustFindOne(q *RepositoryQuery) *Repository {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Repository with the data in the database and
// makes it writable.
func (s *RepositoryStore) Reload(record *Repository) error {
	return s.Store.Reload(Schema.Repository.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *RepositoryStore) Transaction(callback func(*RepositoryStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&RepositoryStore{store})
	})
}

// RepositoryQuery is the object used to create queries for the Repository
// entity.
type RepositoryQuery struct {
	*kallax.BaseQuery
}

// NewRepositoryQuery returns a new instance of RepositoryQuery.
func NewRepositoryQuery() *RepositoryQuery {
	return &RepositoryQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Repository.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *RepositoryQuery) Select(columns ...kallax.SchemaField) *RepositoryQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *RepositoryQuery) SelectNot(columns ...kallax.SchemaField) *RepositoryQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *RepositoryQuery) Copy() *RepositoryQuery {
	return &RepositoryQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *RepositoryQuery) Order(cols ...kallax.ColumnOrder) *RepositoryQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *RepositoryQuery) BatchSize(size uint64) *RepositoryQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *RepositoryQuery) Limit(n uint64) *RepositoryQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *RepositoryQuery) Offset(n uint64) *RepositoryQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *RepositoryQuery) Where(cond kallax.Condition) *RepositoryQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *RepositoryQuery) FindByKallaxID(v ...int64) *RepositoryQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Repository.KallaxID, values...))
}

// FindByTopics adds a new filter to the query that will require that
// the Topics property contains all the passed values; if no passed values,
// it will do nothing.
func (q *RepositoryQuery) FindByTopics(v ...string) *RepositoryQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Repository.Topics, values...))
}

// FindByOwnerID adds a new filter to the query that will require that
// the OwnerID property is equal to the passed value.
func (q *RepositoryQuery) FindByOwnerID(cond kallax.ScalarCond, v int64) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.OwnerID, v))
}

// FindByOwnerType adds a new filter to the query that will require that
// the OwnerType property is equal to the passed value.
func (q *RepositoryQuery) FindByOwnerType(v string) *RepositoryQuery {
	return q.Where(kallax.Eq(Schema.Repository.OwnerType, v))
}

// FindByOwnerLogin adds a new filter to the query that will require that
// the OwnerLogin property is equal to the passed value.
func (q *RepositoryQuery) FindByOwnerLogin(v string) *RepositoryQuery {
	return q.Where(kallax.Eq(Schema.Repository.OwnerLogin, v))
}

// FindByOrganizationID adds a new filter to the query that will require that
// the OrganizationID property is equal to the passed value.
func (q *RepositoryQuery) FindByOrganizationID(cond kallax.ScalarCond, v int64) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.OrganizationID, v))
}

// FindByOrganizationName adds a new filter to the query that will require that
// the OrganizationName property is equal to the passed value.
func (q *RepositoryQuery) FindByOrganizationName(v string) *RepositoryQuery {
	return q.Where(kallax.Eq(Schema.Repository.OrganizationName, v))
}

// RepositoryResultSet is the set of results returned by a query to the
// database.
type RepositoryResultSet struct {
	ResultSet kallax.ResultSet
	last      *Repository
	lastErr   error
}

// NewRepositoryResultSet creates a new result set for rows of the type
// Repository.
func NewRepositoryResultSet(rs kallax.ResultSet) *RepositoryResultSet {
	return &RepositoryResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *RepositoryResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Repository.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Repository)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Repository")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *RepositoryResultSet) Get() (*Repository, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *RepositoryResultSet) ForEach(fn func(*Repository) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *RepositoryResultSet) All() ([]*Repository, error) {
	var result []*Repository
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *RepositoryResultSet) One() (*Repository, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *RepositoryResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *RepositoryResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewUser returns a new instance of User.
func NewUser() (record *User) {
	return new(User)
}

// GetID returns the primary key of the model.
func (r *User) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.KallaxID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *User) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return (*kallax.NumericID)(&r.KallaxID), nil
	case "login":
		return types.Nullable(&r.User.Login), nil
	case "id":
		return types.Nullable(&r.User.ID), nil
	case "node_id":
		return types.Nullable(&r.User.NodeID), nil
	case "avatar_url":
		return types.Nullable(&r.User.AvatarURL), nil
	case "htmlurl":
		return types.Nullable(&r.User.HTMLURL), nil
	case "gravatar_id":
		return types.Nullable(&r.User.GravatarID), nil
	case "name":
		return types.Nullable(&r.User.Name), nil
	case "company":
		return types.Nullable(&r.User.Company), nil
	case "blog":
		return types.Nullable(&r.User.Blog), nil
	case "location":
		return types.Nullable(&r.User.Location), nil
	case "email":
		return types.Nullable(&r.User.Email), nil
	case "hireable":
		return types.Nullable(&r.User.Hireable), nil
	case "bio":
		return types.Nullable(&r.User.Bio), nil
	case "public_repos":
		return types.Nullable(&r.User.PublicRepos), nil
	case "public_gists":
		return types.Nullable(&r.User.PublicGists), nil
	case "followers":
		return types.Nullable(&r.User.Followers), nil
	case "following":
		return types.Nullable(&r.User.Following), nil
	case "created_at":
		if r.CreatedAt == nil {
			r.CreatedAt = new(github.Timestamp)
		}
		return types.JSON(r.User.CreatedAt), nil
	case "updated_at":
		if r.UpdatedAt == nil {
			r.UpdatedAt = new(github.Timestamp)
		}
		return types.JSON(r.User.UpdatedAt), nil
	case "suspended_at":
		if r.SuspendedAt == nil {
			r.SuspendedAt = new(github.Timestamp)
		}
		return types.JSON(r.User.SuspendedAt), nil
	case "type":
		return types.Nullable(&r.User.Type), nil
	case "site_admin":
		return types.Nullable(&r.User.SiteAdmin), nil
	case "total_private_repos":
		return types.Nullable(&r.User.TotalPrivateRepos), nil
	case "owned_private_repos":
		return types.Nullable(&r.User.OwnedPrivateRepos), nil
	case "private_gists":
		return types.Nullable(&r.User.PrivateGists), nil
	case "disk_usage":
		return types.Nullable(&r.User.DiskUsage), nil
	case "collaborators":
		return types.Nullable(&r.User.Collaborators), nil
	case "two_factor_authentication":
		return types.Nullable(&r.User.TwoFactorAuthentication), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// Value returns the value of the given column.
func (r *User) Value(col string) (interface{}, error) {
	switch col {
	case "kallax_id":
		return r.KallaxID, nil
	case "login":
		if r.User.Login == (*string)(nil) {
			return nil, nil
		}
		return r.User.Login, nil
	case "id":
		if r.User.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.User.ID, nil
	case "node_id":
		if r.User.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.User.NodeID, nil
	case "avatar_url":
		if r.User.AvatarURL == (*string)(nil) {
			return nil, nil
		}
		return r.User.AvatarURL, nil
	case "htmlurl":
		if r.User.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.User.HTMLURL, nil
	case "gravatar_id":
		if r.User.GravatarID == (*string)(nil) {
			return nil, nil
		}
		return r.User.GravatarID, nil
	case "name":
		if r.User.Name == (*string)(nil) {
			return nil, nil
		}
		return r.User.Name, nil
	case "company":
		if r.User.Company == (*string)(nil) {
			return nil, nil
		}
		return r.User.Company, nil
	case "blog":
		if r.User.Blog == (*string)(nil) {
			return nil, nil
		}
		return r.User.Blog, nil
	case "location":
		if r.User.Location == (*string)(nil) {
			return nil, nil
		}
		return r.User.Location, nil
	case "email":
		if r.User.Email == (*string)(nil) {
			return nil, nil
		}
		return r.User.Email, nil
	case "hireable":
		if r.User.Hireable == (*bool)(nil) {
			return nil, nil
		}
		return r.User.Hireable, nil
	case "bio":
		if r.User.Bio == (*string)(nil) {
			return nil, nil
		}
		return r.User.Bio, nil
	case "public_repos":
		if r.User.PublicRepos == (*int)(nil) {
			return nil, nil
		}
		return r.User.PublicRepos, nil
	case "public_gists":
		if r.User.PublicGists == (*int)(nil) {
			return nil, nil
		}
		return r.User.PublicGists, nil
	case "followers":
		if r.User.Followers == (*int)(nil) {
			return nil, nil
		}
		return r.User.Followers, nil
	case "following":
		if r.User.Following == (*int)(nil) {
			return nil, nil
		}
		return r.User.Following, nil
	case "created_at":
		if r.User.CreatedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return types.JSON(r.User.CreatedAt), nil
	case "updated_at":
		if r.User.UpdatedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return types.JSON(r.User.UpdatedAt), nil
	case "suspended_at":
		if r.User.SuspendedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return types.JSON(r.User.SuspendedAt), nil
	case "type":
		if r.User.Type == (*string)(nil) {
			return nil, nil
		}
		return r.User.Type, nil
	case "site_admin":
		if r.User.SiteAdmin == (*bool)(nil) {
			return nil, nil
		}
		return r.User.SiteAdmin, nil
	case "total_private_repos":
		if r.User.TotalPrivateRepos == (*int)(nil) {
			return nil, nil
		}
		return r.User.TotalPrivateRepos, nil
	case "owned_private_repos":
		if r.User.OwnedPrivateRepos == (*int)(nil) {
			return nil, nil
		}
		return r.User.OwnedPrivateRepos, nil
	case "private_gists":
		if r.User.PrivateGists == (*int)(nil) {
			return nil, nil
		}
		return r.User.PrivateGists, nil
	case "disk_usage":
		if r.User.DiskUsage == (*int)(nil) {
			return nil, nil
		}
		return r.User.DiskUsage, nil
	case "collaborators":
		if r.User.Collaborators == (*int)(nil) {
			return nil, nil
		}
		return r.User.Collaborators, nil
	case "two_factor_authentication":
		if r.User.TwoFactorAuthentication == (*bool)(nil) {
			return nil, nil
		}
		return r.User.TwoFactorAuthentication, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in User: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *User) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model User has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *User) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model User has no relationships")
}

// UserStore is the entity to access the records of the type User
// in the database.
type UserStore struct {
	*kallax.Store
}

// NewUserStore creates a new instance of UserStore
// using a SQL database.
func NewUserStore(db *sql.DB) *UserStore {
	return &UserStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *UserStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *UserStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *UserStore) Debug() *UserStore {
	return &UserStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *UserStore) DebugWith(logger kallax.LoggerFunc) *UserStore {
	return &UserStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *UserStore) DisableCacher() *UserStore {
	return &UserStore{s.Store.DisableCacher()}
}

// Insert inserts a User in the database. A non-persisted object is
// required for this operation.
func (s *UserStore) Insert(record *User) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.User.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *UserStore) Update(record *User, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.User.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *UserStore) Save(record *User) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *UserStore) Delete(record *User) error {
	return s.Store.Delete(Schema.User.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *UserStore) Find(q *UserQuery) (*UserResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewUserResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *UserStore) MustFind(q *UserQuery) *UserResultSet {
	return NewUserResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *UserStore) Count(q *UserQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *UserStore) MustCount(q *UserQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *UserStore) FindOne(q *UserQuery) (*User, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *UserStore) FindAll(q *UserQuery) ([]*User, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *UserStore) MustFindOne(q *UserQuery) *User {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the User with the data in the database and
// makes it writable.
func (s *UserStore) Reload(record *User) error {
	return s.Store.Reload(Schema.User.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *UserStore) Transaction(callback func(*UserStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&UserStore{store})
	})
}

// UserQuery is the object used to create queries for the User
// entity.
type UserQuery struct {
	*kallax.BaseQuery
}

// NewUserQuery returns a new instance of UserQuery.
func NewUserQuery() *UserQuery {
	return &UserQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.User.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *UserQuery) Select(columns ...kallax.SchemaField) *UserQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *UserQuery) SelectNot(columns ...kallax.SchemaField) *UserQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *UserQuery) Copy() *UserQuery {
	return &UserQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *UserQuery) Order(cols ...kallax.ColumnOrder) *UserQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *UserQuery) BatchSize(size uint64) *UserQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *UserQuery) Limit(n uint64) *UserQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *UserQuery) Offset(n uint64) *UserQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *UserQuery) Where(cond kallax.Condition) *UserQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByKallaxID adds a new filter to the query that will require that
// the KallaxID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *UserQuery) FindByKallaxID(v ...int64) *UserQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.User.KallaxID, values...))
}

// UserResultSet is the set of results returned by a query to the
// database.
type UserResultSet struct {
	ResultSet kallax.ResultSet
	last      *User
	lastErr   error
}

// NewUserResultSet creates a new result set for rows of the type
// User.
func NewUserResultSet(rs kallax.ResultSet) *UserResultSet {
	return &UserResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *UserResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.User.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*User)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *User")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *UserResultSet) Get() (*User, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *UserResultSet) ForEach(fn func(*User) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *UserResultSet) All() ([]*User, error) {
	var result []*User
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *UserResultSet) One() (*User, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *UserResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *UserResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Issue              *schemaIssue
	IssueComment       *schemaIssueComment
	Organization       *schemaOrganization
	PullRequest        *schemaPullRequest
	PullRequestComment *schemaPullRequestComment
	PullRequestReview  *schemaPullRequestReview
	Repository         *schemaRepository
	User               *schemaUser
}

type schemaIssue struct {
	*kallax.BaseSchema
	KallaxID        kallax.SchemaField
	ID              kallax.SchemaField
	Number          kallax.SchemaField
	State           kallax.SchemaField
	Locked          kallax.SchemaField
	Title           kallax.SchemaField
	Body            kallax.SchemaField
	Comments        kallax.SchemaField
	ClosedAt        kallax.SchemaField
	CreatedAt       kallax.SchemaField
	UpdatedAt       kallax.SchemaField
	HTMLURL         kallax.SchemaField
	NodeID          kallax.SchemaField
	RepositoryOwner kallax.SchemaField
	RepositoryName  kallax.SchemaField
	LabelList       kallax.SchemaField
	UserID          kallax.SchemaField
	UserLogin       kallax.SchemaField
	AssigneeID      kallax.SchemaField
	AssigneeLogin   kallax.SchemaField
	AssigneesList   *schemaIssueAssigneesList
	ClosedByID      kallax.SchemaField
	ClosedByLogin   kallax.SchemaField
	MilestoneID     kallax.SchemaField
	MilestoneTitle  kallax.SchemaField
}

type schemaIssueComment struct {
	*kallax.BaseSchema
	KallaxID          kallax.SchemaField
	ID                kallax.SchemaField
	NodeID            kallax.SchemaField
	Body              kallax.SchemaField
	Reactions         *schemaIssueCommentReactions
	CreatedAt         kallax.SchemaField
	UpdatedAt         kallax.SchemaField
	AuthorAssociation kallax.SchemaField
	HTMLURL           kallax.SchemaField
	UserID            kallax.SchemaField
	UserLogin         kallax.SchemaField
	IssueNumber       kallax.SchemaField
	RepositoryOwner   kallax.SchemaField
	RepositoryName    kallax.SchemaField
}

type schemaOrganization struct {
	*kallax.BaseSchema
	KallaxID                    kallax.SchemaField
	Login                       kallax.SchemaField
	ID                          kallax.SchemaField
	NodeID                      kallax.SchemaField
	AvatarURL                   kallax.SchemaField
	HTMLURL                     kallax.SchemaField
	Name                        kallax.SchemaField
	Company                     kallax.SchemaField
	Blog                        kallax.SchemaField
	Location                    kallax.SchemaField
	Email                       kallax.SchemaField
	Description                 kallax.SchemaField
	PublicRepos                 kallax.SchemaField
	PublicGists                 kallax.SchemaField
	Followers                   kallax.SchemaField
	Following                   kallax.SchemaField
	CreatedAt                   kallax.SchemaField
	UpdatedAt                   kallax.SchemaField
	TotalPrivateRepos           kallax.SchemaField
	OwnedPrivateRepos           kallax.SchemaField
	PrivateGists                kallax.SchemaField
	DiskUsage                   kallax.SchemaField
	Collaborators               kallax.SchemaField
	BillingEmail                kallax.SchemaField
	Type                        kallax.SchemaField
	TwoFactorRequirementEnabled kallax.SchemaField
}

type schemaPullRequest struct {
	*kallax.BaseSchema
	KallaxID               kallax.SchemaField
	ID                     kallax.SchemaField
	Number                 kallax.SchemaField
	State                  kallax.SchemaField
	Title                  kallax.SchemaField
	Body                   kallax.SchemaField
	CreatedAt              kallax.SchemaField
	UpdatedAt              kallax.SchemaField
	ClosedAt               kallax.SchemaField
	MergedAt               kallax.SchemaField
	Draft                  kallax.SchemaField
	Merged                 kallax.SchemaField
	Mergeable              kallax.SchemaField
	MergeableState         kallax.SchemaField
	MergeCommitSHA         kallax.SchemaField
	Comments               kallax.SchemaField
	Commits                kallax.SchemaField
	Additions              kallax.SchemaField
	Deletions              kallax.SchemaField
	ChangedFiles           kallax.SchemaField
	HTMLURL                kallax.SchemaField
	ReviewComments         kallax.SchemaField
	MaintainerCanModify    kallax.SchemaField
	AuthorAssociation      kallax.SchemaField
	NodeID                 kallax.SchemaField
	RepositoryOwner        kallax.SchemaField
	RepositoryName         kallax.SchemaField
	LabelList              kallax.SchemaField
	UserID                 kallax.SchemaField
	UserLogin              kallax.SchemaField
	MergedByID             kallax.SchemaField
	MergedByLogin          kallax.SchemaField
	AssigneeID             kallax.SchemaField
	AssigneeLogin          kallax.SchemaField
	AssigneesList          *schemaPullRequestAssigneesList
	RequestedReviewersList *schemaPullRequestRequestedReviewersList
	MilestoneID            kallax.SchemaField
	MilestoneTitle         kallax.SchemaField
	HeadSHA                kallax.SchemaField
	HeadRef                kallax.SchemaField
	HeadLabel              kallax.SchemaField
	HeadUser               kallax.SchemaField
	HeadRepositoryOwner    kallax.SchemaField
	HeadRepositoryName     kallax.SchemaField
	BaseSHA                kallax.SchemaField
	BaseRef                kallax.SchemaField
	BaseLabel              kallax.SchemaField
	BaseUser               kallax.SchemaField
	BaseRepositoryOwner    kallax.SchemaField
	BaseRepositoryName     kallax.SchemaField
}

type schemaPullRequestComment struct {
	*kallax.BaseSchema
	KallaxID            kallax.SchemaField
	ID                  kallax.SchemaField
	NodeID              kallax.SchemaField
	InReplyTo           kallax.SchemaField
	Body                kallax.SchemaField
	Path                kallax.SchemaField
	DiffHunk            kallax.SchemaField
	PullRequestReviewID kallax.SchemaField
	Position            kallax.SchemaField
	OriginalPosition    kallax.SchemaField
	CommitID            kallax.SchemaField
	OriginalCommitID    kallax.SchemaField
	Reactions           *schemaPullRequestCommentReactions
	CreatedAt           kallax.SchemaField
	UpdatedAt           kallax.SchemaField
	AuthorAssociation   kallax.SchemaField
	HTMLURL             kallax.SchemaField
	UserID              kallax.SchemaField
	UserLogin           kallax.SchemaField
	PullRequestNumber   kallax.SchemaField
	RepositoryOwner     kallax.SchemaField
	RepositoryName      kallax.SchemaField
}

type schemaPullRequestReview struct {
	*kallax.BaseSchema
	KallaxID          kallax.SchemaField
	ID                kallax.SchemaField
	NodeID            kallax.SchemaField
	Body              kallax.SchemaField
	SubmittedAt       kallax.SchemaField
	CommitID          kallax.SchemaField
	HTMLURL           kallax.SchemaField
	State             kallax.SchemaField
	UserID            kallax.SchemaField
	UserLogin         kallax.SchemaField
	PullRequestNumber kallax.SchemaField
	RepositoryOwner   kallax.SchemaField
	RepositoryName    kallax.SchemaField
}

type schemaRepository struct {
	*kallax.BaseSchema
	KallaxID          kallax.SchemaField
	ID                kallax.SchemaField
	NodeID            kallax.SchemaField
	Name              kallax.SchemaField
	FullName          kallax.SchemaField
	Description       kallax.SchemaField
	Homepage          kallax.SchemaField
	CodeOfConduct     *schemaRepositoryCodeOfConduct
	DefaultBranch     kallax.SchemaField
	MasterBranch      kallax.SchemaField
	CreatedAt         *schemaRepositoryCreatedAt
	PushedAt          *schemaRepositoryPushedAt
	UpdatedAt         *schemaRepositoryUpdatedAt
	HTMLURL           kallax.SchemaField
	CloneURL          kallax.SchemaField
	GitURL            kallax.SchemaField
	MirrorURL         kallax.SchemaField
	SSHURL            kallax.SchemaField
	SVNURL            kallax.SchemaField
	Language          kallax.SchemaField
	Fork              kallax.SchemaField
	ForksCount        kallax.SchemaField
	NetworkCount      kallax.SchemaField
	OpenIssuesCount   kallax.SchemaField
	StargazersCount   kallax.SchemaField
	SubscribersCount  kallax.SchemaField
	WatchersCount     kallax.SchemaField
	Size              kallax.SchemaField
	AutoInit          kallax.SchemaField
	Permissions       kallax.SchemaField
	AllowRebaseMerge  kallax.SchemaField
	AllowSquashMerge  kallax.SchemaField
	AllowMergeCommit  kallax.SchemaField
	Topics            kallax.SchemaField
	Archived          kallax.SchemaField
	Disabled          kallax.SchemaField
	License           *schemaRepositoryLicense
	Private           kallax.SchemaField
	HasIssues         kallax.SchemaField
	HasWiki           kallax.SchemaField
	HasPages          kallax.SchemaField
	HasProjects       kallax.SchemaField
	HasDownloads      kallax.SchemaField
	LicenseTemplate   kallax.SchemaField
	GitignoreTemplate kallax.SchemaField
	TeamID            kallax.SchemaField
	ParentRepository  *schemaRepositoryParentRepository
	SourceRepository  *schemaRepositorySourceRepository
	OwnerID           kallax.SchemaField
	OwnerType         kallax.SchemaField
	OwnerLogin        kallax.SchemaField
	OrganizationID    kallax.SchemaField
	OrganizationName  kallax.SchemaField
}

type schemaUser struct {
	*kallax.BaseSchema
	KallaxID                kallax.SchemaField
	Login                   kallax.SchemaField
	ID                      kallax.SchemaField
	NodeID                  kallax.SchemaField
	AvatarURL               kallax.SchemaField
	HTMLURL                 kallax.SchemaField
	GravatarID              kallax.SchemaField
	Name                    kallax.SchemaField
	Company                 kallax.SchemaField
	Blog                    kallax.SchemaField
	Location                kallax.SchemaField
	Email                   kallax.SchemaField
	Hireable                kallax.SchemaField
	Bio                     kallax.SchemaField
	PublicRepos             kallax.SchemaField
	PublicGists             kallax.SchemaField
	Followers               kallax.SchemaField
	Following               kallax.SchemaField
	CreatedAt               *schemaUserCreatedAt
	UpdatedAt               *schemaUserUpdatedAt
	SuspendedAt             *schemaUserSuspendedAt
	Type                    kallax.SchemaField
	SiteAdmin               kallax.SchemaField
	TotalPrivateRepos       kallax.SchemaField
	OwnedPrivateRepos       kallax.SchemaField
	PrivateGists            kallax.SchemaField
	DiskUsage               kallax.SchemaField
	Collaborators           kallax.SchemaField
	TwoFactorAuthentication kallax.SchemaField
}

type schemaIssueAssigneesList struct {
	*kallax.BaseSchemaField
	ID    kallax.SchemaField
	Login kallax.SchemaField
}

func (s *schemaIssueAssigneesList) At(n int) *schemaIssueAssigneesList {
	return &schemaIssueAssigneesList{
		BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
		ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", fmt.Sprint(n), "id"),
		Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", fmt.Sprint(n), "login"),
	}
}

type schemaIssueCommentReactions struct {
	*kallax.BaseSchemaField
	TotalCount kallax.SchemaField
	PlusOne    kallax.SchemaField
	MinusOne   kallax.SchemaField
	Laugh      kallax.SchemaField
	Confused   kallax.SchemaField
	Heart      kallax.SchemaField
	Hooray     kallax.SchemaField
}

type schemaPullRequestAssigneesList struct {
	*kallax.BaseSchemaField
	ID    kallax.SchemaField
	Login kallax.SchemaField
}

func (s *schemaPullRequestAssigneesList) At(n int) *schemaPullRequestAssigneesList {
	return &schemaPullRequestAssigneesList{
		BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
		ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", fmt.Sprint(n), "id"),
		Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", fmt.Sprint(n), "login"),
	}
}

type schemaPullRequestCommentReactions struct {
	*kallax.BaseSchemaField
	TotalCount kallax.SchemaField
	PlusOne    kallax.SchemaField
	MinusOne   kallax.SchemaField
	Laugh      kallax.SchemaField
	Confused   kallax.SchemaField
	Heart      kallax.SchemaField
	Hooray     kallax.SchemaField
}

type schemaPullRequestRequestedReviewersList struct {
	*kallax.BaseSchemaField
	ID    kallax.SchemaField
	Login kallax.SchemaField
}

func (s *schemaPullRequestRequestedReviewersList) At(n int) *schemaPullRequestRequestedReviewersList {
	return &schemaPullRequestRequestedReviewersList{
		BaseSchemaField: kallax.NewSchemaField("requested_reviewers").(*kallax.BaseSchemaField),
		ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "requested_reviewers", fmt.Sprint(n), "id"),
		Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "requested_reviewers", fmt.Sprint(n), "login"),
	}
}

type schemaRepositoryCodeOfConduct struct {
	*kallax.BaseSchemaField
	Name kallax.SchemaField
	Key  kallax.SchemaField
	Body kallax.SchemaField
}

type schemaRepositoryCreatedAt struct {
	*kallax.BaseSchemaField
}

type schemaRepositoryLicense struct {
	*kallax.BaseSchemaField
	Key            kallax.SchemaField
	Name           kallax.SchemaField
	SPDXID         kallax.SchemaField
	HTMLURL        kallax.SchemaField
	Featured       kallax.SchemaField
	Description    kallax.SchemaField
	Implementation kallax.SchemaField
	Permissions    kallax.SchemaField
	Conditions     kallax.SchemaField
	Limitations    kallax.SchemaField
	Body           kallax.SchemaField
}

type schemaRepositoryParentRepository struct {
	*kallax.BaseSchemaField
	ID         kallax.SchemaField
	Name       kallax.SchemaField
	Fork       kallax.SchemaField
	Size       kallax.SchemaField
	OwnerLogin kallax.SchemaField
	OwnerType  kallax.SchemaField
	OwnerID    kallax.SchemaField
}

type schemaRepositoryPushedAt struct {
	*kallax.BaseSchemaField
}

type schemaRepositorySourceRepository struct {
	*kallax.BaseSchemaField
	ID         kallax.SchemaField
	Name       kallax.SchemaField
	Fork       kallax.SchemaField
	Size       kallax.SchemaField
	OwnerLogin kallax.SchemaField
	OwnerType  kallax.SchemaField
	OwnerID    kallax.SchemaField
}

type schemaRepositoryUpdatedAt struct {
	*kallax.BaseSchemaField
}

type schemaUserCreatedAt struct {
	*kallax.BaseSchemaField
}

type schemaUserSuspendedAt struct {
	*kallax.BaseSchemaField
}

type schemaUserUpdatedAt struct {
	*kallax.BaseSchemaField
}

var Schema = &schema{
	Issue: &schemaIssue{
		BaseSchema: kallax.NewBaseSchema(
			"issues",
			"__issue",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Issue)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("number"),
			kallax.NewSchemaField("state"),
			kallax.NewSchemaField("locked"),
			kallax.NewSchemaField("title"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("comments"),
			kallax.NewSchemaField("closed_at"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
			kallax.NewSchemaField("labels"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("assignee_id"),
			kallax.NewSchemaField("assignee_login"),
			kallax.NewSchemaField("assignees"),
			kallax.NewSchemaField("closed_by_id"),
			kallax.NewSchemaField("closed_by_login"),
			kallax.NewSchemaField("milestone_id"),
			kallax.NewSchemaField("milestone_title"),
		),
		KallaxID:        kallax.NewSchemaField("kallax_id"),
		ID:              kallax.NewSchemaField("id"),
		Number:          kallax.NewSchemaField("number"),
		State:           kallax.NewSchemaField("state"),
		Locked:          kallax.NewSchemaField("locked"),
		Title:           kallax.NewSchemaField("title"),
		Body:            kallax.NewSchemaField("body"),
		Comments:        kallax.NewSchemaField("comments"),
		ClosedAt:        kallax.NewSchemaField("closed_at"),
		CreatedAt:       kallax.NewSchemaField("created_at"),
		UpdatedAt:       kallax.NewSchemaField("updated_at"),
		HTMLURL:         kallax.NewSchemaField("htmlurl"),
		NodeID:          kallax.NewSchemaField("node_id"),
		RepositoryOwner: kallax.NewSchemaField("repository_owner"),
		RepositoryName:  kallax.NewSchemaField("repository_name"),
		LabelList:       kallax.NewSchemaField("labels"),
		UserID:          kallax.NewSchemaField("user_id"),
		UserLogin:       kallax.NewSchemaField("user_login"),
		AssigneeID:      kallax.NewSchemaField("assignee_id"),
		AssigneeLogin:   kallax.NewSchemaField("assignee_login"),
		AssigneesList: &schemaIssueAssigneesList{
			BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", "id"),
			Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", "login"),
		},
		ClosedByID:     kallax.NewSchemaField("closed_by_id"),
		ClosedByLogin:  kallax.NewSchemaField("closed_by_login"),
		MilestoneID:    kallax.NewSchemaField("milestone_id"),
		MilestoneTitle: kallax.NewSchemaField("milestone_title"),
	},
	IssueComment: &schemaIssueComment{
		BaseSchema: kallax.NewBaseSchema(
			"issue_comments",
			"__issuecomment",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(IssueComment)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("reactions"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("author_association"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("issue_number"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
		),
		KallaxID: kallax.NewSchemaField("kallax_id"),
		ID:       kallax.NewSchemaField("id"),
		NodeID:   kallax.NewSchemaField("node_id"),
		Body:     kallax.NewSchemaField("body"),
		Reactions: &schemaIssueCommentReactions{
			BaseSchemaField: kallax.NewSchemaField("reactions").(*kallax.BaseSchemaField),
			TotalCount:      kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "total_count"),
			PlusOne:         kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "+1"),
			MinusOne:        kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "-1"),
			Laugh:           kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "laugh"),
			Confused:        kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "confused"),
			Heart:           kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "heart"),
			Hooray:          kallax.NewJSONSchemaKey(kallax.JSONInt, "issue_comment", "reactions", "hooray"),
		},
		CreatedAt:         kallax.NewSchemaField("created_at"),
		UpdatedAt:         kallax.NewSchemaField("updated_at"),
		AuthorAssociation: kallax.NewSchemaField("author_association"),
		HTMLURL:           kallax.NewSchemaField("htmlurl"),
		UserID:            kallax.NewSchemaField("user_id"),
		UserLogin:         kallax.NewSchemaField("user_login"),
		IssueNumber:       kallax.NewSchemaField("issue_number"),
		RepositoryOwner:   kallax.NewSchemaField("repository_owner"),
		RepositoryName:    kallax.NewSchemaField("repository_name"),
	},
	Organization: &schemaOrganization{
		BaseSchema: kallax.NewBaseSchema(
			"organizations",
			"__organization",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Organization)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("login"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("avatar_url"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("company"),
			kallax.NewSchemaField("blog"),
			kallax.NewSchemaField("location"),
			kallax.NewSchemaField("email"),
			kallax.NewSchemaField("description"),
			kallax.NewSchemaField("public_repos"),
			kallax.NewSchemaField("public_gists"),
			kallax.NewSchemaField("followers"),
			kallax.NewSchemaField("following"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("total_private_repos"),
			kallax.NewSchemaField("owned_private_repos"),
			kallax.NewSchemaField("private_gists"),
			kallax.NewSchemaField("disk_usage"),
			kallax.NewSchemaField("collaborators"),
			kallax.NewSchemaField("billing_email"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("two_factor_requirement_enabled"),
		),
		KallaxID:                    kallax.NewSchemaField("kallax_id"),
		Login:                       kallax.NewSchemaField("login"),
		ID:                          kallax.NewSchemaField("id"),
		NodeID:                      kallax.NewSchemaField("node_id"),
		AvatarURL:                   kallax.NewSchemaField("avatar_url"),
		HTMLURL:                     kallax.NewSchemaField("htmlurl"),
		Name:                        kallax.NewSchemaField("name"),
		Company:                     kallax.NewSchemaField("company"),
		Blog:                        kallax.NewSchemaField("blog"),
		Location:                    kallax.NewSchemaField("location"),
		Email:                       kallax.NewSchemaField("email"),
		Description:                 kallax.NewSchemaField("description"),
		PublicRepos:                 kallax.NewSchemaField("public_repos"),
		PublicGists:                 kallax.NewSchemaField("public_gists"),
		Followers:                   kallax.NewSchemaField("followers"),
		Following:                   kallax.NewSchemaField("following"),
		CreatedAt:                   kallax.NewSchemaField("created_at"),
		UpdatedAt:                   kallax.NewSchemaField("updated_at"),
		TotalPrivateRepos:           kallax.NewSchemaField("total_private_repos"),
		OwnedPrivateRepos:           kallax.NewSchemaField("owned_private_repos"),
		PrivateGists:                kallax.NewSchemaField("private_gists"),
		DiskUsage:                   kallax.NewSchemaField("disk_usage"),
		Collaborators:               kallax.NewSchemaField("collaborators"),
		BillingEmail:                kallax.NewSchemaField("billing_email"),
		Type:                        kallax.NewSchemaField("type"),
		TwoFactorRequirementEnabled: kallax.NewSchemaField("two_factor_requirement_enabled"),
	},
	PullRequest: &schemaPullRequest{
		BaseSchema: kallax.NewBaseSchema(
			"pull_requests",
			"__pullrequest",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(PullRequest)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("number"),
			kallax.NewSchemaField("state"),
			kallax.NewSchemaField("title"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("closed_at"),
			kallax.NewSchemaField("merged_at"),
			kallax.NewSchemaField("draft"),
			kallax.NewSchemaField("merged"),
			kallax.NewSchemaField("mergeable"),
			kallax.NewSchemaField("mergeable_state"),
			kallax.NewSchemaField("merge_commit_sha"),
			kallax.NewSchemaField("comments"),
			kallax.NewSchemaField("commits"),
			kallax.NewSchemaField("additions"),
			kallax.NewSchemaField("deletions"),
			kallax.NewSchemaField("changed_files"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("review_comments"),
			kallax.NewSchemaField("maintainer_can_modify"),
			kallax.NewSchemaField("author_association"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
			kallax.NewSchemaField("labels"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("merged_by_id"),
			kallax.NewSchemaField("merged_by_login"),
			kallax.NewSchemaField("assignee_id"),
			kallax.NewSchemaField("assignee_login"),
			kallax.NewSchemaField("assignees"),
			kallax.NewSchemaField("requested_reviewers"),
			kallax.NewSchemaField("milestone_id"),
			kallax.NewSchemaField("milestone_title"),
			kallax.NewSchemaField("head_sha"),
			kallax.NewSchemaField("head_ref"),
			kallax.NewSchemaField("head_label"),
			kallax.NewSchemaField("head_user"),
			kallax.NewSchemaField("head_repository_owner"),
			kallax.NewSchemaField("head_repository_name"),
			kallax.NewSchemaField("base_sha"),
			kallax.NewSchemaField("base_ref"),
			kallax.NewSchemaField("base_label"),
			kallax.NewSchemaField("base_user"),
			kallax.NewSchemaField("base_repository_owner"),
			kallax.NewSchemaField("base_repository_name"),
		),
		KallaxID:            kallax.NewSchemaField("kallax_id"),
		ID:                  kallax.NewSchemaField("id"),
		Number:              kallax.NewSchemaField("number"),
		State:               kallax.NewSchemaField("state"),
		Title:               kallax.NewSchemaField("title"),
		Body:                kallax.NewSchemaField("body"),
		CreatedAt:           kallax.NewSchemaField("created_at"),
		UpdatedAt:           kallax.NewSchemaField("updated_at"),
		ClosedAt:            kallax.NewSchemaField("closed_at"),
		MergedAt:            kallax.NewSchemaField("merged_at"),
		Draft:               kallax.NewSchemaField("draft"),
		Merged:              kallax.NewSchemaField("merged"),
		Mergeable:           kallax.NewSchemaField("mergeable"),
		MergeableState:      kallax.NewSchemaField("mergeable_state"),
		MergeCommitSHA:      kallax.NewSchemaField("merge_commit_sha"),
		Comments:            kallax.NewSchemaField("comments"),
		Commits:             kallax.NewSchemaField("commits"),
		Additions:           kallax.NewSchemaField("additions"),
		Deletions:           kallax.NewSchemaField("deletions"),
		ChangedFiles:        kallax.NewSchemaField("changed_files"),
		HTMLURL:             kallax.NewSchemaField("htmlurl"),
		ReviewComments:      kallax.NewSchemaField("review_comments"),
		MaintainerCanModify: kallax.NewSchemaField("maintainer_can_modify"),
		AuthorAssociation:   kallax.NewSchemaField("author_association"),
		NodeID:              kallax.NewSchemaField("node_id"),
		RepositoryOwner:     kallax.NewSchemaField("repository_owner"),
		RepositoryName:      kallax.NewSchemaField("repository_name"),
		LabelList:           kallax.NewSchemaField("labels"),
		UserID:              kallax.NewSchemaField("user_id"),
		UserLogin:           kallax.NewSchemaField("user_login"),
		MergedByID:          kallax.NewSchemaField("merged_by_id"),
		MergedByLogin:       kallax.NewSchemaField("merged_by_login"),
		AssigneeID:          kallax.NewSchemaField("assignee_id"),
		AssigneeLogin:       kallax.NewSchemaField("assignee_login"),
		AssigneesList: &schemaPullRequestAssigneesList{
			BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", "id"),
			Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", "login"),
		},
		RequestedReviewersList: &schemaPullRequestRequestedReviewersList{
			BaseSchemaField: kallax.NewSchemaField("requested_reviewers").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "requested_reviewers", "id"),
			Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "requested_reviewers", "login"),
		},
		MilestoneID:         kallax.NewSchemaField("milestone_id"),
		MilestoneTitle:      kallax.NewSchemaField("milestone_title"),
		HeadSHA:             kallax.NewSchemaField("head_sha"),
		HeadRef:             kallax.NewSchemaField("head_ref"),
		HeadLabel:           kallax.NewSchemaField("head_label"),
		HeadUser:            kallax.NewSchemaField("head_user"),
		HeadRepositoryOwner: kallax.NewSchemaField("head_repository_owner"),
		HeadRepositoryName:  kallax.NewSchemaField("head_repository_name"),
		BaseSHA:             kallax.NewSchemaField("base_sha"),
		BaseRef:             kallax.NewSchemaField("base_ref"),
		BaseLabel:           kallax.NewSchemaField("base_label"),
		BaseUser:            kallax.NewSchemaField("base_user"),
		BaseRepositoryOwner: kallax.NewSchemaField("base_repository_owner"),
		BaseRepositoryName:  kallax.NewSchemaField("base_repository_name"),
	},
	PullRequestComment: &schemaPullRequestComment{
		BaseSchema: kallax.NewBaseSchema(
			"pull_request_comments",
			"__pullrequestcomment",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(PullRequestComment)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("in_reply_to"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("path"),
			kallax.NewSchemaField("diff_hunk"),
			kallax.NewSchemaField("pull_request_review_id"),
			kallax.NewSchemaField("position"),
			kallax.NewSchemaField("original_position"),
			kallax.NewSchemaField("commit_id"),
			kallax.NewSchemaField("original_commit_id"),
			kallax.NewSchemaField("reactions"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("author_association"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("pull_request_number"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
		),
		KallaxID:            kallax.NewSchemaField("kallax_id"),
		ID:                  kallax.NewSchemaField("id"),
		NodeID:              kallax.NewSchemaField("node_id"),
		InReplyTo:           kallax.NewSchemaField("in_reply_to"),
		Body:                kallax.NewSchemaField("body"),
		Path:                kallax.NewSchemaField("path"),
		DiffHunk:            kallax.NewSchemaField("diff_hunk"),
		PullRequestReviewID: kallax.NewSchemaField("pull_request_review_id"),
		Position:            kallax.NewSchemaField("position"),
		OriginalPosition:    kallax.NewSchemaField("original_position"),
		CommitID:            kallax.NewSchemaField("commit_id"),
		OriginalCommitID:    kallax.NewSchemaField("original_commit_id"),
		Reactions: &schemaPullRequestCommentReactions{
			BaseSchemaField: kallax.NewSchemaField("reactions").(*kallax.BaseSchemaField),
			TotalCount:      kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "total_count"),
			PlusOne:         kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "+1"),
			MinusOne:        kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "-1"),
			Laugh:           kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "laugh"),
			Confused:        kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "confused"),
			Heart:           kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "heart"),
			Hooray:          kallax.NewJSONSchemaKey(kallax.JSONInt, "pull_request_comment", "reactions", "hooray"),
		},
		CreatedAt:         kallax.NewSchemaField("created_at"),
		UpdatedAt:         kallax.NewSchemaField("updated_at"),
		AuthorAssociation: kallax.NewSchemaField("author_association"),
		HTMLURL:           kallax.NewSchemaField("htmlurl"),
		UserID:            kallax.NewSchemaField("user_id"),
		UserLogin:         kallax.NewSchemaField("user_login"),
		PullRequestNumber: kallax.NewSchemaField("pull_request_number"),
		RepositoryOwner:   kallax.NewSchemaField("repository_owner"),
		RepositoryName:    kallax.NewSchemaField("repository_name"),
	},
	PullRequestReview: &schemaPullRequestReview{
		BaseSchema: kallax.NewBaseSchema(
			"pull_request_reviews",
			"__pullrequestreview",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(PullRequestReview)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("submitted_at"),
			kallax.NewSchemaField("commit_id"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("state"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("pull_request_number"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
		),
		KallaxID:          kallax.NewSchemaField("kallax_id"),
		ID:                kallax.NewSchemaField("id"),
		NodeID:            kallax.NewSchemaField("node_id"),
		Body:              kallax.NewSchemaField("body"),
		SubmittedAt:       kallax.NewSchemaField("submitted_at"),
		CommitID:          kallax.NewSchemaField("commit_id"),
		HTMLURL:           kallax.NewSchemaField("htmlurl"),
		State:             kallax.NewSchemaField("state"),
		UserID:            kallax.NewSchemaField("user_id"),
		UserLogin:         kallax.NewSchemaField("user_login"),
		PullRequestNumber: kallax.NewSchemaField("pull_request_number"),
		RepositoryOwner:   kallax.NewSchemaField("repository_owner"),
		RepositoryName:    kallax.NewSchemaField("repository_name"),
	},
	Repository: &schemaRepository{
		BaseSchema: kallax.NewBaseSchema(
			"repositories",
			"__repository",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Repository)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("full_name"),
			kallax.NewSchemaField("description"),
			kallax.NewSchemaField("homepage"),
			kallax.NewSchemaField("code_of_conduct"),
			kallax.NewSchemaField("default_branch"),
			kallax.NewSchemaField("master_branch"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("pushed_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("clone_url"),
			kallax.NewSchemaField("git_url"),
			kallax.NewSchemaField("mirror_url"),
			kallax.NewSchemaField("sshurl"),
			kallax.NewSchemaField("svnurl"),
			kallax.NewSchemaField("language"),
			kallax.NewSchemaField("fork"),
			kallax.NewSchemaField("forks_count"),
			kallax.NewSchemaField("network_count"),
			kallax.NewSchemaField("open_issues_count"),
			kallax.NewSchemaField("stargazers_count"),
			kallax.NewSchemaField("subscribers_count"),
			kallax.NewSchemaField("watchers_count"),
			kallax.NewSchemaField("size"),
			kallax.NewSchemaField("auto_init"),
			kallax.NewSchemaField("permissions"),
			kallax.NewSchemaField("allow_rebase_merge"),
			kallax.NewSchemaField("allow_squash_merge"),
			kallax.NewSchemaField("allow_merge_commit"),
			kallax.NewSchemaField("topics"),
			kallax.NewSchemaField("archived"),
			kallax.NewSchemaField("disabled"),
			kallax.NewSchemaField("license"),
			kallax.NewSchemaField("private"),
			kallax.NewSchemaField("has_issues"),
			kallax.NewSchemaField("has_wiki"),
			kallax.NewSchemaField("has_pages"),
			kallax.NewSchemaField("has_projects"),
			kallax.NewSchemaField("has_downloads"),
			kallax.NewSchemaField("license_template"),
			kallax.NewSchemaField("gitignore_template"),
			kallax.NewSchemaField("team_id"),
			kallax.NewSchemaField("parent"),
			kallax.NewSchemaField("source"),
			kallax.NewSchemaField("owner_id"),
			kallax.NewSchemaField("owner_type"),
			kallax.NewSchemaField("owner_login"),
			kallax.NewSchemaField("organization_id"),
			kallax.NewSchemaField("organization_name"),
		),
		KallaxID:    kallax.NewSchemaField("kallax_id"),
		ID:          kallax.NewSchemaField("id"),
		NodeID:      kallax.NewSchemaField("node_id"),
		Name:        kallax.NewSchemaField("name"),
		FullName:    kallax.NewSchemaField("full_name"),
		Description: kallax.NewSchemaField("description"),
		Homepage:    kallax.NewSchemaField("homepage"),
		CodeOfConduct: &schemaRepositoryCodeOfConduct{
			BaseSchemaField: kallax.NewSchemaField("code_of_conduct").(*kallax.BaseSchemaField),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "name"),
			Key:             kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "key"),
			Body:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "body"),
		},
		DefaultBranch: kallax.NewSchemaField("default_branch"),
		MasterBranch:  kallax.NewSchemaField("master_branch"),
		CreatedAt: &schemaRepositoryCreatedAt{
			BaseSchemaField: kallax.NewSchemaField("created_at").(*kallax.BaseSchemaField),
		},
		PushedAt: &schemaRepositoryPushedAt{
			BaseSchemaField: kallax.NewSchemaField("pushed_at").(*kallax.BaseSchemaField),
		},
		UpdatedAt: &schemaRepositoryUpdatedAt{
			BaseSchemaField: kallax.NewSchemaField("updated_at").(*kallax.BaseSchemaField),
		},
		HTMLURL:          kallax.NewSchemaField("htmlurl"),
		CloneURL:         kallax.NewSchemaField("clone_url"),
		GitURL:           kallax.NewSchemaField("git_url"),
		MirrorURL:        kallax.NewSchemaField("mirror_url"),
		SSHURL:           kallax.NewSchemaField("sshurl"),
		SVNURL:           kallax.NewSchemaField("svnurl"),
		Language:         kallax.NewSchemaField("language"),
		Fork:             kallax.NewSchemaField("fork"),
		ForksCount:       kallax.NewSchemaField("forks_count"),
		NetworkCount:     kallax.NewSchemaField("network_count"),
		OpenIssuesCount:  kallax.NewSchemaField("open_issues_count"),
		StargazersCount:  kallax.NewSchemaField("stargazers_count"),
		SubscribersCount: kallax.NewSchemaField("subscribers_count"),
		WatchersCount:    kallax.NewSchemaField("watchers_count"),
		Size:             kallax.NewSchemaField("size"),
		AutoInit:         kallax.NewSchemaField("auto_init"),
		Permissions:      kallax.NewSchemaField("permissions"),
		AllowRebaseMerge: kallax.NewSchemaField("allow_rebase_merge"),
		AllowSquashMerge: kallax.NewSchemaField("allow_squash_merge"),
		AllowMergeCommit: kallax.NewSchemaField("allow_merge_commit"),
		Topics:           kallax.NewSchemaField("topics"),
		Archived:         kallax.NewSchemaField("archived"),
		Disabled:         kallax.NewSchemaField("disabled"),
		License: &schemaRepositoryLicense{
			BaseSchemaField: kallax.NewSchemaField("license").(*kallax.BaseSchemaField),
			Key:             kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "key"),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "name"),
			SPDXID:          kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "spdx_id"),
			HTMLURL:         kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "html_url"),
			Featured:        kallax.NewJSONSchemaKey(kallax.JSONBool, "repository", "license", "featured"),
			Description:     kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "description"),
			Implementation:  kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "implementation"),
			Permissions:     kallax.NewJSONSchemaKey(kallax.JSONAny, "repository", "license", "permissions"),
			Conditions:      kallax.NewJSONSchemaKey(kallax.JSONAny, "repository", "license", "conditions"),
			Limitations:     kallax.NewJSONSchemaKey(kallax.JSONAny, "repository", "license", "limitations"),
			Body:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "body"),
		},
		Private:           kallax.NewSchemaField("private"),
		HasIssues:         kallax.NewSchemaField("has_issues"),
		HasWiki:           kallax.NewSchemaField("has_wiki"),
		HasPages:          kallax.NewSchemaField("has_pages"),
		HasProjects:       kallax.NewSchemaField("has_projects"),
		HasDownloads:      kallax.NewSchemaField("has_downloads"),
		LicenseTemplate:   kallax.NewSchemaField("license_template"),
		GitignoreTemplate: kallax.NewSchemaField("gitignore_template"),
		TeamID:            kallax.NewSchemaField("team_id"),
		ParentRepository: &schemaRepositoryParentRepository{
			BaseSchemaField: kallax.NewSchemaField("parent").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "parent", "id"),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "parent", "name"),
			Fork:            kallax.NewJSONSchemaKey(kallax.JSONBool, "parent", "fork"),
			Size:            kallax.NewJSONSchemaKey(kallax.JSONInt, "parent", "size"),
			OwnerLogin:      kallax.NewJSONSchemaKey(kallax.JSONText, "parent", "owner_login"),
			OwnerType:       kallax.NewJSONSchemaKey(kallax.JSONText, "parent", "owner_type"),
			OwnerID:         kallax.NewJSONSchemaKey(kallax.JSONInt, "parent", "owner_id"),
		},
		SourceRepository: &schemaRepositorySourceRepository{
			BaseSchemaField: kallax.NewSchemaField("source").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "source", "id"),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "source", "name"),
			Fork:            kallax.NewJSONSchemaKey(kallax.JSONBool, "source", "fork"),
			Size:            kallax.NewJSONSchemaKey(kallax.JSONInt, "source", "size"),
			OwnerLogin:      kallax.NewJSONSchemaKey(kallax.JSONText, "source", "owner_login"),
			OwnerType:       kallax.NewJSONSchemaKey(kallax.JSONText, "source", "owner_type"),
			OwnerID:         kallax.NewJSONSchemaKey(kallax.JSONInt, "source", "owner_id"),
		},
		OwnerID:          kallax.NewSchemaField("owner_id"),
		OwnerType:        kallax.NewSchemaField("owner_type"),
		OwnerLogin:       kallax.NewSchemaField("owner_login"),
		OrganizationID:   kallax.NewSchemaField("organization_id"),
		OrganizationName: kallax.NewSchemaField("organization_name"),
	},
	User: &schemaUser{
		BaseSchema: kallax.NewBaseSchema(
			"users",
			"__user",
			kallax.NewSchemaField("kallax_id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(User)
			},
			false,
			kallax.NewSchemaField("kallax_id"),
			kallax.NewSchemaField("login"),
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("avatar_url"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("gravatar_id"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("company"),
			kallax.NewSchemaField("blog"),
			kallax.NewSchemaField("location"),
			kallax.NewSchemaField("email"),
			kallax.NewSchemaField("hireable"),
			kallax.NewSchemaField("bio"),
			kallax.NewSchemaField("public_repos"),
			kallax.NewSchemaField("public_gists"),
			kallax.NewSchemaField("followers"),
			kallax.NewSchemaField("following"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("suspended_at"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("site_admin"),
			kallax.NewSchemaField("total_private_repos"),
			kallax.NewSchemaField("owned_private_repos"),
			kallax.NewSchemaField("private_gists"),
			kallax.NewSchemaField("disk_usage"),
			kallax.NewSchemaField("collaborators"),
			kallax.NewSchemaField("two_factor_authentication"),
		),
		KallaxID:    kallax.NewSchemaField("kallax_id"),
		Login:       kallax.NewSchemaField("login"),
		ID:          kallax.NewSchemaField("id"),
		NodeID:      kallax.NewSchemaField("node_id"),
		AvatarURL:   kallax.NewSchemaField("avatar_url"),
		HTMLURL:     kallax.NewSchemaField("htmlurl"),
		GravatarID:  kallax.NewSchemaField("gravatar_id"),
		Name:        kallax.NewSchemaField("name"),
		Company:     kallax.NewSchemaField("company"),
		Blog:        kallax.NewSchemaField("blog"),
		Location:    kallax.NewSchemaField("location"),
		Email:       kallax.NewSchemaField("email"),
		Hireable:    kallax.NewSchemaField("hireable"),
		Bio:         kallax.NewSchemaField("bio"),
		PublicRepos: kallax.NewSchemaField("public_repos"),
		PublicGists: kallax.NewSchemaField("public_gists"),
		Followers:   kallax.NewSchemaField("followers"),
		Following:   kallax.NewSchemaField("following"),
		CreatedAt: &schemaUserCreatedAt{
			BaseSchemaField: kallax.NewSchemaField("created_at").(*kallax.BaseSchemaField),
		},
		UpdatedAt: &schemaUserUpdatedAt{
			BaseSchemaField: kallax.NewSchemaField("updated_at").(*kallax.BaseSchemaField),
		},
		SuspendedAt: &schemaUserSuspendedAt{
			BaseSchemaField: kallax.NewSchemaField("suspended_at").(*kallax.BaseSchemaField),
		},
		Type:                    kallax.NewSchemaField("type"),
		SiteAdmin:               kallax.NewSchemaField("site_admin"),
		TotalPrivateRepos:       kallax.NewSchemaField("total_private_repos"),
		OwnedPrivateRepos:       kallax.NewSchemaField("owned_private_repos"),
		PrivateGists:            kallax.NewSchemaField("private_gists"),
		DiskUsage:               kallax.NewSchemaField("disk_usage"),
		Collaborators:           kallax.NewSchemaField("collaborators"),
		TwoFactorAuthentication: kallax.NewSchemaField("two_factor_authentication"),
	},
}
