// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package models

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/google/go-github/github"
	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewIssue returns a new instance of Issue.
func NewIssue() (record *Issue) {
	return new(Issue)
}

// GetID returns the primary key of the model.
func (r *Issue) GetID() kallax.Identifier {
	return (*kallax.NumericID)(r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Issue) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(r.Issue.ID), nil
	case "number":
		return types.Nullable(&r.Issue.Number), nil
	case "state":
		return types.Nullable(&r.Issue.State), nil
	case "locked":
		return types.Nullable(&r.Issue.Locked), nil
	case "title":
		return types.Nullable(&r.Issue.Title), nil
	case "body":
		return types.Nullable(&r.Issue.Body), nil
	case "comments":
		return types.Nullable(&r.Issue.Comments), nil
	case "closed_at":
		return types.Nullable(&r.Issue.ClosedAt), nil
	case "created_at":
		return types.Nullable(&r.Issue.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.Issue.UpdatedAt), nil
	case "url":
		return types.Nullable(&r.Issue.URL), nil
	case "htmlurl":
		return types.Nullable(&r.Issue.HTMLURL), nil
	case "comments_url":
		return types.Nullable(&r.Issue.CommentsURL), nil
	case "events_url":
		return types.Nullable(&r.Issue.EventsURL), nil
	case "labels_url":
		return types.Nullable(&r.Issue.LabelsURL), nil
	case "repository_url":
		return types.Nullable(&r.Issue.RepositoryURL), nil
	case "reactions":
		if r.Reactions == nil {
			r.Reactions = new(github.Reactions)
		}
		return types.JSON(r.Issue.Reactions), nil
	case "node_id":
		return types.Nullable(&r.Issue.NodeID), nil
	case "active_lock_reason":
		return types.Nullable(&r.Issue.ActiveLockReason), nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil
	case "labels":
		return types.Slice(&r.LabelList), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "assignee_id":
		return &r.AssigneeID, nil
	case "assignee_login":
		return &r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(&r.AssigneesList), nil
	case "closed_by_id":
		return &r.ClosedByID, nil
	case "closed_by_login":
		return &r.ClosedByLogin, nil
	case "milestone_id":
		return &r.MilestoneID, nil
	case "milestone_title":
		return &r.MilestoneTitle, nil
	case "pull_request_url":
		return &r.PullRequestURL, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Issue: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Issue) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		if r.Issue.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.Issue.ID, nil
	case "number":
		if r.Issue.Number == (*int)(nil) {
			return nil, nil
		}
		return r.Issue.Number, nil
	case "state":
		if r.Issue.State == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.State, nil
	case "locked":
		if r.Issue.Locked == (*bool)(nil) {
			return nil, nil
		}
		return r.Issue.Locked, nil
	case "title":
		if r.Issue.Title == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.Title, nil
	case "body":
		if r.Issue.Body == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.Body, nil
	case "comments":
		if r.Issue.Comments == (*int)(nil) {
			return nil, nil
		}
		return r.Issue.Comments, nil
	case "closed_at":
		if r.Issue.ClosedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Issue.ClosedAt, nil
	case "created_at":
		if r.Issue.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Issue.CreatedAt, nil
	case "updated_at":
		if r.Issue.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Issue.UpdatedAt, nil
	case "url":
		if r.Issue.URL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.URL, nil
	case "htmlurl":
		if r.Issue.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.HTMLURL, nil
	case "comments_url":
		if r.Issue.CommentsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.CommentsURL, nil
	case "events_url":
		if r.Issue.EventsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.EventsURL, nil
	case "labels_url":
		if r.Issue.LabelsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.LabelsURL, nil
	case "repository_url":
		if r.Issue.RepositoryURL == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.RepositoryURL, nil
	case "reactions":
		if r.Issue.Reactions == (*github.Reactions)(nil) {
			return nil, nil
		}
		return types.JSON(r.Issue.Reactions), nil
	case "node_id":
		if r.Issue.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.NodeID, nil
	case "active_lock_reason":
		if r.Issue.ActiveLockReason == (*string)(nil) {
			return nil, nil
		}
		return r.Issue.ActiveLockReason, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil
	case "labels":
		return types.Slice(r.LabelList), nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "assignee_id":
		return r.AssigneeID, nil
	case "assignee_login":
		return r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(r.AssigneesList), nil
	case "closed_by_id":
		return r.ClosedByID, nil
	case "closed_by_login":
		return r.ClosedByLogin, nil
	case "milestone_id":
		return r.MilestoneID, nil
	case "milestone_title":
		return r.MilestoneTitle, nil
	case "pull_request_url":
		return r.PullRequestURL, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Issue: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Issue) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Issue has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Issue) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Issue has no relationships")
}

// IssueStore is the entity to access the records of the type Issue
// in the database.
type IssueStore struct {
	*kallax.Store
}

// NewIssueStore creates a new instance of IssueStore
// using a SQL database.
func NewIssueStore(db *sql.DB) *IssueStore {
	return &IssueStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *IssueStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *IssueStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *IssueStore) Debug() *IssueStore {
	return &IssueStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *IssueStore) DebugWith(logger kallax.LoggerFunc) *IssueStore {
	return &IssueStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *IssueStore) DisableCacher() *IssueStore {
	return &IssueStore{s.Store.DisableCacher()}
}

// Insert inserts a Issue in the database. A non-persisted object is
// required for this operation.
func (s *IssueStore) Insert(record *Issue) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Issue.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *IssueStore) Update(record *Issue, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Issue.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *IssueStore) Save(record *Issue) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *IssueStore) Delete(record *Issue) error {
	return s.Store.Delete(Schema.Issue.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *IssueStore) Find(q *IssueQuery) (*IssueResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewIssueResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *IssueStore) MustFind(q *IssueQuery) *IssueResultSet {
	return NewIssueResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *IssueStore) Count(q *IssueQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *IssueStore) MustCount(q *IssueQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *IssueStore) FindOne(q *IssueQuery) (*Issue, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *IssueStore) FindAll(q *IssueQuery) ([]*Issue, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *IssueStore) MustFindOne(q *IssueQuery) *Issue {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Issue with the data in the database and
// makes it writable.
func (s *IssueStore) Reload(record *Issue) error {
	return s.Store.Reload(Schema.Issue.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *IssueStore) Transaction(callback func(*IssueStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&IssueStore{store})
	})
}

// IssueQuery is the object used to create queries for the Issue
// entity.
type IssueQuery struct {
	*kallax.BaseQuery
}

// NewIssueQuery returns a new instance of IssueQuery.
func NewIssueQuery() *IssueQuery {
	return &IssueQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Issue.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *IssueQuery) Select(columns ...kallax.SchemaField) *IssueQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *IssueQuery) SelectNot(columns ...kallax.SchemaField) *IssueQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *IssueQuery) Copy() *IssueQuery {
	return &IssueQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *IssueQuery) Order(cols ...kallax.ColumnOrder) *IssueQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *IssueQuery) BatchSize(size uint64) *IssueQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *IssueQuery) Limit(n uint64) *IssueQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *IssueQuery) Offset(n uint64) *IssueQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *IssueQuery) Where(cond kallax.Condition) *IssueQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByClosedAt adds a new filter to the query that will require that
// the ClosedAt property is equal to the passed value.
func (q *IssueQuery) FindByClosedAt(cond kallax.ScalarCond, v time.Time) *IssueQuery {
	return q.Where(cond(Schema.Issue.ClosedAt, v))
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *IssueQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *IssueQuery {
	return q.Where(cond(Schema.Issue.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *IssueQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *IssueQuery {
	return q.Where(cond(Schema.Issue.UpdatedAt, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *IssueQuery) FindByRepositoryOwner(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *IssueQuery) FindByRepositoryName(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.RepositoryName, v))
}

// FindByLabelList adds a new filter to the query that will require that
// the LabelList property contains all the passed values; if no passed values,
// it will do nothing.
func (q *IssueQuery) FindByLabelList(v ...string) *IssueQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Issue.LabelList, values...))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *IssueQuery) FindByUserID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *IssueQuery) FindByUserLogin(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.UserLogin, v))
}

// FindByAssigneeID adds a new filter to the query that will require that
// the AssigneeID property is equal to the passed value.
func (q *IssueQuery) FindByAssigneeID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.AssigneeID, v))
}

// FindByAssigneeLogin adds a new filter to the query that will require that
// the AssigneeLogin property is equal to the passed value.
func (q *IssueQuery) FindByAssigneeLogin(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.AssigneeLogin, v))
}

// FindByClosedByID adds a new filter to the query that will require that
// the ClosedByID property is equal to the passed value.
func (q *IssueQuery) FindByClosedByID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.ClosedByID, v))
}

// FindByClosedByLogin adds a new filter to the query that will require that
// the ClosedByLogin property is equal to the passed value.
func (q *IssueQuery) FindByClosedByLogin(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.ClosedByLogin, v))
}

// FindByMilestoneID adds a new filter to the query that will require that
// the MilestoneID property is equal to the passed value.
func (q *IssueQuery) FindByMilestoneID(cond kallax.ScalarCond, v int64) *IssueQuery {
	return q.Where(cond(Schema.Issue.MilestoneID, v))
}

// FindByMilestoneTitle adds a new filter to the query that will require that
// the MilestoneTitle property is equal to the passed value.
func (q *IssueQuery) FindByMilestoneTitle(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.MilestoneTitle, v))
}

// FindByPullRequestURL adds a new filter to the query that will require that
// the PullRequestURL property is equal to the passed value.
func (q *IssueQuery) FindByPullRequestURL(v string) *IssueQuery {
	return q.Where(kallax.Eq(Schema.Issue.PullRequestURL, v))
}

// IssueResultSet is the set of results returned by a query to the
// database.
type IssueResultSet struct {
	ResultSet kallax.ResultSet
	last      *Issue
	lastErr   error
}

// NewIssueResultSet creates a new result set for rows of the type
// Issue.
func NewIssueResultSet(rs kallax.ResultSet) *IssueResultSet {
	return &IssueResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *IssueResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Issue.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Issue)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Issue")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *IssueResultSet) Get() (*Issue, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *IssueResultSet) ForEach(fn func(*Issue) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *IssueResultSet) All() ([]*Issue, error) {
	var result []*Issue
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *IssueResultSet) One() (*Issue, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *IssueResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *IssueResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewOrganization returns a new instance of Organization.
func NewOrganization() (record *Organization) {
	return new(Organization)
}

// GetID returns the primary key of the model.
func (r *Organization) GetID() kallax.Identifier {
	return (*kallax.NumericID)(r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Organization) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(r.Organization.ID), nil
	case "login":
		return types.Nullable(&r.Organization.Login), nil
	case "node_id":
		return types.Nullable(&r.Organization.NodeID), nil
	case "avatar_url":
		return types.Nullable(&r.Organization.AvatarURL), nil
	case "htmlurl":
		return types.Nullable(&r.Organization.HTMLURL), nil
	case "name":
		return types.Nullable(&r.Organization.Name), nil
	case "company":
		return types.Nullable(&r.Organization.Company), nil
	case "blog":
		return types.Nullable(&r.Organization.Blog), nil
	case "location":
		return types.Nullable(&r.Organization.Location), nil
	case "email":
		return types.Nullable(&r.Organization.Email), nil
	case "description":
		return types.Nullable(&r.Organization.Description), nil
	case "public_repos":
		return types.Nullable(&r.Organization.PublicRepos), nil
	case "public_gists":
		return types.Nullable(&r.Organization.PublicGists), nil
	case "followers":
		return types.Nullable(&r.Organization.Followers), nil
	case "following":
		return types.Nullable(&r.Organization.Following), nil
	case "created_at":
		return types.Nullable(&r.Organization.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.Organization.UpdatedAt), nil
	case "total_private_repos":
		return types.Nullable(&r.Organization.TotalPrivateRepos), nil
	case "owned_private_repos":
		return types.Nullable(&r.Organization.OwnedPrivateRepos), nil
	case "private_gists":
		return types.Nullable(&r.Organization.PrivateGists), nil
	case "disk_usage":
		return types.Nullable(&r.Organization.DiskUsage), nil
	case "collaborators":
		return types.Nullable(&r.Organization.Collaborators), nil
	case "billing_email":
		return types.Nullable(&r.Organization.BillingEmail), nil
	case "type":
		return types.Nullable(&r.Organization.Type), nil
	case "plan":
		if r.Plan == nil {
			r.Plan = new(github.Plan)
		}
		return types.JSON(r.Organization.Plan), nil
	case "two_factor_requirement_enabled":
		return types.Nullable(&r.Organization.TwoFactorRequirementEnabled), nil
	case "default_repo_permission":
		return types.Nullable(&r.Organization.DefaultRepoPermission), nil
	case "default_repo_settings":
		return types.Nullable(&r.Organization.DefaultRepoSettings), nil
	case "members_can_create_repos":
		return types.Nullable(&r.Organization.MembersCanCreateRepos), nil
	case "url":
		return types.Nullable(&r.Organization.URL), nil
	case "events_url":
		return types.Nullable(&r.Organization.EventsURL), nil
	case "hooks_url":
		return types.Nullable(&r.Organization.HooksURL), nil
	case "issues_url":
		return types.Nullable(&r.Organization.IssuesURL), nil
	case "members_url":
		return types.Nullable(&r.Organization.MembersURL), nil
	case "public_members_url":
		return types.Nullable(&r.Organization.PublicMembersURL), nil
	case "repos_url":
		return types.Nullable(&r.Organization.ReposURL), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organization: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Organization) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		if r.Organization.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.Organization.ID, nil
	case "login":
		if r.Organization.Login == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Login, nil
	case "node_id":
		if r.Organization.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.NodeID, nil
	case "avatar_url":
		if r.Organization.AvatarURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.AvatarURL, nil
	case "htmlurl":
		if r.Organization.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.HTMLURL, nil
	case "name":
		if r.Organization.Name == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Name, nil
	case "company":
		if r.Organization.Company == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Company, nil
	case "blog":
		if r.Organization.Blog == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Blog, nil
	case "location":
		if r.Organization.Location == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Location, nil
	case "email":
		if r.Organization.Email == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Email, nil
	case "description":
		if r.Organization.Description == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Description, nil
	case "public_repos":
		if r.Organization.PublicRepos == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.PublicRepos, nil
	case "public_gists":
		if r.Organization.PublicGists == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.PublicGists, nil
	case "followers":
		if r.Organization.Followers == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.Followers, nil
	case "following":
		if r.Organization.Following == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.Following, nil
	case "created_at":
		if r.Organization.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Organization.CreatedAt, nil
	case "updated_at":
		if r.Organization.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Organization.UpdatedAt, nil
	case "total_private_repos":
		if r.Organization.TotalPrivateRepos == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.TotalPrivateRepos, nil
	case "owned_private_repos":
		if r.Organization.OwnedPrivateRepos == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.OwnedPrivateRepos, nil
	case "private_gists":
		if r.Organization.PrivateGists == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.PrivateGists, nil
	case "disk_usage":
		if r.Organization.DiskUsage == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.DiskUsage, nil
	case "collaborators":
		if r.Organization.Collaborators == (*int)(nil) {
			return nil, nil
		}
		return r.Organization.Collaborators, nil
	case "billing_email":
		if r.Organization.BillingEmail == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.BillingEmail, nil
	case "type":
		if r.Organization.Type == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.Type, nil
	case "plan":
		if r.Organization.Plan == (*github.Plan)(nil) {
			return nil, nil
		}
		return types.JSON(r.Organization.Plan), nil
	case "two_factor_requirement_enabled":
		if r.Organization.TwoFactorRequirementEnabled == (*bool)(nil) {
			return nil, nil
		}
		return r.Organization.TwoFactorRequirementEnabled, nil
	case "default_repo_permission":
		if r.Organization.DefaultRepoPermission == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.DefaultRepoPermission, nil
	case "default_repo_settings":
		if r.Organization.DefaultRepoSettings == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.DefaultRepoSettings, nil
	case "members_can_create_repos":
		if r.Organization.MembersCanCreateRepos == (*bool)(nil) {
			return nil, nil
		}
		return r.Organization.MembersCanCreateRepos, nil
	case "url":
		if r.Organization.URL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.URL, nil
	case "events_url":
		if r.Organization.EventsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.EventsURL, nil
	case "hooks_url":
		if r.Organization.HooksURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.HooksURL, nil
	case "issues_url":
		if r.Organization.IssuesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.IssuesURL, nil
	case "members_url":
		if r.Organization.MembersURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.MembersURL, nil
	case "public_members_url":
		if r.Organization.PublicMembersURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.PublicMembersURL, nil
	case "repos_url":
		if r.Organization.ReposURL == (*string)(nil) {
			return nil, nil
		}
		return r.Organization.ReposURL, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organization: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Organization) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Organization has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Organization) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Organization has no relationships")
}

// OrganizationStore is the entity to access the records of the type Organization
// in the database.
type OrganizationStore struct {
	*kallax.Store
}

// NewOrganizationStore creates a new instance of OrganizationStore
// using a SQL database.
func NewOrganizationStore(db *sql.DB) *OrganizationStore {
	return &OrganizationStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *OrganizationStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *OrganizationStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *OrganizationStore) Debug() *OrganizationStore {
	return &OrganizationStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *OrganizationStore) DebugWith(logger kallax.LoggerFunc) *OrganizationStore {
	return &OrganizationStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *OrganizationStore) DisableCacher() *OrganizationStore {
	return &OrganizationStore{s.Store.DisableCacher()}
}

// Insert inserts a Organization in the database. A non-persisted object is
// required for this operation.
func (s *OrganizationStore) Insert(record *Organization) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	return s.Store.Insert(Schema.Organization.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *OrganizationStore) Update(record *Organization, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Organization.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *OrganizationStore) Save(record *Organization) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *OrganizationStore) Delete(record *Organization) error {
	return s.Store.Delete(Schema.Organization.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *OrganizationStore) Find(q *OrganizationQuery) (*OrganizationResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewOrganizationResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *OrganizationStore) MustFind(q *OrganizationQuery) *OrganizationResultSet {
	return NewOrganizationResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *OrganizationStore) Count(q *OrganizationQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *OrganizationStore) MustCount(q *OrganizationQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *OrganizationStore) FindOne(q *OrganizationQuery) (*Organization, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *OrganizationStore) FindAll(q *OrganizationQuery) ([]*Organization, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *OrganizationStore) MustFindOne(q *OrganizationQuery) *Organization {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Organization with the data in the database and
// makes it writable.
func (s *OrganizationStore) Reload(record *Organization) error {
	return s.Store.Reload(Schema.Organization.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *OrganizationStore) Transaction(callback func(*OrganizationStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&OrganizationStore{store})
	})
}

// OrganizationQuery is the object used to create queries for the Organization
// entity.
type OrganizationQuery struct {
	*kallax.BaseQuery
}

// NewOrganizationQuery returns a new instance of OrganizationQuery.
func NewOrganizationQuery() *OrganizationQuery {
	return &OrganizationQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Organization.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *OrganizationQuery) Select(columns ...kallax.SchemaField) *OrganizationQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *OrganizationQuery) SelectNot(columns ...kallax.SchemaField) *OrganizationQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *OrganizationQuery) Copy() *OrganizationQuery {
	return &OrganizationQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *OrganizationQuery) Order(cols ...kallax.ColumnOrder) *OrganizationQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *OrganizationQuery) BatchSize(size uint64) *OrganizationQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *OrganizationQuery) Limit(n uint64) *OrganizationQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *OrganizationQuery) Offset(n uint64) *OrganizationQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *OrganizationQuery) Where(cond kallax.Condition) *OrganizationQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *OrganizationQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *OrganizationQuery {
	return q.Where(cond(Schema.Organization.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *OrganizationQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *OrganizationQuery {
	return q.Where(cond(Schema.Organization.UpdatedAt, v))
}

// OrganizationResultSet is the set of results returned by a query to the
// database.
type OrganizationResultSet struct {
	ResultSet kallax.ResultSet
	last      *Organization
	lastErr   error
}

// NewOrganizationResultSet creates a new result set for rows of the type
// Organization.
func NewOrganizationResultSet(rs kallax.ResultSet) *OrganizationResultSet {
	return &OrganizationResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *OrganizationResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Organization.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Organization)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Organization")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *OrganizationResultSet) Get() (*Organization, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *OrganizationResultSet) ForEach(fn func(*Organization) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *OrganizationResultSet) All() ([]*Organization, error) {
	var result []*Organization
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *OrganizationResultSet) One() (*Organization, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *OrganizationResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *OrganizationResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewPullRequest returns a new instance of PullRequest.
func NewPullRequest() (record *PullRequest) {
	return new(PullRequest)
}

// GetID returns the primary key of the model.
func (r *PullRequest) GetID() kallax.Identifier {
	return (*kallax.NumericID)(r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *PullRequest) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(r.PullRequest.ID), nil
	case "number":
		return types.Nullable(&r.PullRequest.Number), nil
	case "state":
		return types.Nullable(&r.PullRequest.State), nil
	case "title":
		return types.Nullable(&r.PullRequest.Title), nil
	case "body":
		return types.Nullable(&r.PullRequest.Body), nil
	case "created_at":
		return types.Nullable(&r.PullRequest.CreatedAt), nil
	case "updated_at":
		return types.Nullable(&r.PullRequest.UpdatedAt), nil
	case "closed_at":
		return types.Nullable(&r.PullRequest.ClosedAt), nil
	case "merged_at":
		return types.Nullable(&r.PullRequest.MergedAt), nil
	case "draft":
		return types.Nullable(&r.PullRequest.Draft), nil
	case "merged":
		return types.Nullable(&r.PullRequest.Merged), nil
	case "mergeable":
		return types.Nullable(&r.PullRequest.Mergeable), nil
	case "mergeable_state":
		return types.Nullable(&r.PullRequest.MergeableState), nil
	case "merge_commit_sha":
		return types.Nullable(&r.PullRequest.MergeCommitSHA), nil
	case "comments":
		return types.Nullable(&r.PullRequest.Comments), nil
	case "commits":
		return types.Nullable(&r.PullRequest.Commits), nil
	case "additions":
		return types.Nullable(&r.PullRequest.Additions), nil
	case "deletions":
		return types.Nullable(&r.PullRequest.Deletions), nil
	case "changed_files":
		return types.Nullable(&r.PullRequest.ChangedFiles), nil
	case "url":
		return types.Nullable(&r.PullRequest.URL), nil
	case "htmlurl":
		return types.Nullable(&r.PullRequest.HTMLURL), nil
	case "issue_url":
		return types.Nullable(&r.PullRequest.IssueURL), nil
	case "statuses_url":
		return types.Nullable(&r.PullRequest.StatusesURL), nil
	case "diff_url":
		return types.Nullable(&r.PullRequest.DiffURL), nil
	case "patch_url":
		return types.Nullable(&r.PullRequest.PatchURL), nil
	case "commits_url":
		return types.Nullable(&r.PullRequest.CommitsURL), nil
	case "comments_url":
		return types.Nullable(&r.PullRequest.CommentsURL), nil
	case "review_comments_url":
		return types.Nullable(&r.PullRequest.ReviewCommentsURL), nil
	case "review_comment_url":
		return types.Nullable(&r.PullRequest.ReviewCommentURL), nil
	case "review_comments":
		return types.Nullable(&r.PullRequest.ReviewComments), nil
	case "maintainer_can_modify":
		return types.Nullable(&r.PullRequest.MaintainerCanModify), nil
	case "author_association":
		return types.Nullable(&r.PullRequest.AuthorAssociation), nil
	case "node_id":
		return types.Nullable(&r.PullRequest.NodeID), nil
	case "repository_owner":
		return &r.RepositoryOwner, nil
	case "repository_name":
		return &r.RepositoryName, nil
	case "labels":
		return types.Slice(&r.LabelList), nil
	case "user_id":
		return &r.UserID, nil
	case "user_login":
		return &r.UserLogin, nil
	case "merged_by_id":
		return &r.MergedByID, nil
	case "merged_by_login":
		return &r.MergedByLogin, nil
	case "assignee_id":
		return &r.AssigneeID, nil
	case "assignee_login":
		return &r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(&r.AssigneesList), nil
	case "requested_reviewers":
		return types.JSON(&r.RequestedReviewersList), nil
	case "milestone_id":
		return &r.MilestoneID, nil
	case "milestone_title":
		return &r.MilestoneTitle, nil
	case "head_sha":
		return &r.HeadSHA, nil
	case "head_ref":
		return &r.HeadRef, nil
	case "head_label":
		return &r.HeadLabel, nil
	case "head_user":
		return &r.HeadUser, nil
	case "head_repository_owner":
		return &r.HeadRepositoryOwner, nil
	case "head_repository_name":
		return &r.HeadRepositoryName, nil
	case "base_sha":
		return &r.BaseSHA, nil
	case "base_ref":
		return &r.BaseRef, nil
	case "base_label":
		return &r.BaseLabel, nil
	case "base_user":
		return &r.BaseUser, nil
	case "base_repository_owner":
		return &r.BaseRepositoryOwner, nil
	case "base_repository_name":
		return &r.BaseRepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequest: %s", col)
	}
}

// Value returns the value of the given column.
func (r *PullRequest) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		if r.PullRequest.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.PullRequest.ID, nil
	case "number":
		if r.PullRequest.Number == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Number, nil
	case "state":
		if r.PullRequest.State == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.State, nil
	case "title":
		if r.PullRequest.Title == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.Title, nil
	case "body":
		if r.PullRequest.Body == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.Body, nil
	case "created_at":
		if r.PullRequest.CreatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.CreatedAt, nil
	case "updated_at":
		if r.PullRequest.UpdatedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.UpdatedAt, nil
	case "closed_at":
		if r.PullRequest.ClosedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.ClosedAt, nil
	case "merged_at":
		if r.PullRequest.MergedAt == (*time.Time)(nil) {
			return nil, nil
		}
		return r.PullRequest.MergedAt, nil
	case "draft":
		if r.PullRequest.Draft == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.Draft, nil
	case "merged":
		if r.PullRequest.Merged == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.Merged, nil
	case "mergeable":
		if r.PullRequest.Mergeable == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.Mergeable, nil
	case "mergeable_state":
		if r.PullRequest.MergeableState == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.MergeableState, nil
	case "merge_commit_sha":
		if r.PullRequest.MergeCommitSHA == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.MergeCommitSHA, nil
	case "comments":
		if r.PullRequest.Comments == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Comments, nil
	case "commits":
		if r.PullRequest.Commits == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Commits, nil
	case "additions":
		if r.PullRequest.Additions == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Additions, nil
	case "deletions":
		if r.PullRequest.Deletions == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.Deletions, nil
	case "changed_files":
		if r.PullRequest.ChangedFiles == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.ChangedFiles, nil
	case "url":
		if r.PullRequest.URL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.URL, nil
	case "htmlurl":
		if r.PullRequest.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.HTMLURL, nil
	case "issue_url":
		if r.PullRequest.IssueURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.IssueURL, nil
	case "statuses_url":
		if r.PullRequest.StatusesURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.StatusesURL, nil
	case "diff_url":
		if r.PullRequest.DiffURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.DiffURL, nil
	case "patch_url":
		if r.PullRequest.PatchURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.PatchURL, nil
	case "commits_url":
		if r.PullRequest.CommitsURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.CommitsURL, nil
	case "comments_url":
		if r.PullRequest.CommentsURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.CommentsURL, nil
	case "review_comments_url":
		if r.PullRequest.ReviewCommentsURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.ReviewCommentsURL, nil
	case "review_comment_url":
		if r.PullRequest.ReviewCommentURL == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.ReviewCommentURL, nil
	case "review_comments":
		if r.PullRequest.ReviewComments == (*int)(nil) {
			return nil, nil
		}
		return r.PullRequest.ReviewComments, nil
	case "maintainer_can_modify":
		if r.PullRequest.MaintainerCanModify == (*bool)(nil) {
			return nil, nil
		}
		return r.PullRequest.MaintainerCanModify, nil
	case "author_association":
		if r.PullRequest.AuthorAssociation == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.AuthorAssociation, nil
	case "node_id":
		if r.PullRequest.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.PullRequest.NodeID, nil
	case "repository_owner":
		return r.RepositoryOwner, nil
	case "repository_name":
		return r.RepositoryName, nil
	case "labels":
		return types.Slice(r.LabelList), nil
	case "user_id":
		return r.UserID, nil
	case "user_login":
		return r.UserLogin, nil
	case "merged_by_id":
		return r.MergedByID, nil
	case "merged_by_login":
		return r.MergedByLogin, nil
	case "assignee_id":
		return r.AssigneeID, nil
	case "assignee_login":
		return r.AssigneeLogin, nil
	case "assignees":
		return types.JSON(r.AssigneesList), nil
	case "requested_reviewers":
		return types.JSON(r.RequestedReviewersList), nil
	case "milestone_id":
		return r.MilestoneID, nil
	case "milestone_title":
		return r.MilestoneTitle, nil
	case "head_sha":
		return r.HeadSHA, nil
	case "head_ref":
		return r.HeadRef, nil
	case "head_label":
		return r.HeadLabel, nil
	case "head_user":
		return r.HeadUser, nil
	case "head_repository_owner":
		return r.HeadRepositoryOwner, nil
	case "head_repository_name":
		return r.HeadRepositoryName, nil
	case "base_sha":
		return r.BaseSHA, nil
	case "base_ref":
		return r.BaseRef, nil
	case "base_label":
		return r.BaseLabel, nil
	case "base_user":
		return r.BaseUser, nil
	case "base_repository_owner":
		return r.BaseRepositoryOwner, nil
	case "base_repository_name":
		return r.BaseRepositoryName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in PullRequest: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *PullRequest) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model PullRequest has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *PullRequest) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model PullRequest has no relationships")
}

// PullRequestStore is the entity to access the records of the type PullRequest
// in the database.
type PullRequestStore struct {
	*kallax.Store
}

// NewPullRequestStore creates a new instance of PullRequestStore
// using a SQL database.
func NewPullRequestStore(db *sql.DB) *PullRequestStore {
	return &PullRequestStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *PullRequestStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *PullRequestStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *PullRequestStore) Debug() *PullRequestStore {
	return &PullRequestStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *PullRequestStore) DebugWith(logger kallax.LoggerFunc) *PullRequestStore {
	return &PullRequestStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *PullRequestStore) DisableCacher() *PullRequestStore {
	return &PullRequestStore{s.Store.DisableCacher()}
}

// Insert inserts a PullRequest in the database. A non-persisted object is
// required for this operation.
func (s *PullRequestStore) Insert(record *PullRequest) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}
	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.MergedAt != nil {
		record.MergedAt = func(t time.Time) *time.Time { return &t }(record.MergedAt.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.PullRequest.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *PullRequestStore) Update(record *PullRequest, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.CreatedAt != nil {
		record.CreatedAt = func(t time.Time) *time.Time { return &t }(record.CreatedAt.Truncate(time.Microsecond))
	}
	if record.UpdatedAt != nil {
		record.UpdatedAt = func(t time.Time) *time.Time { return &t }(record.UpdatedAt.Truncate(time.Microsecond))
	}
	if record.ClosedAt != nil {
		record.ClosedAt = func(t time.Time) *time.Time { return &t }(record.ClosedAt.Truncate(time.Microsecond))
	}
	if record.MergedAt != nil {
		record.MergedAt = func(t time.Time) *time.Time { return &t }(record.MergedAt.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.PullRequest.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *PullRequestStore) Save(record *PullRequest) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *PullRequestStore) Delete(record *PullRequest) error {
	return s.Store.Delete(Schema.PullRequest.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *PullRequestStore) Find(q *PullRequestQuery) (*PullRequestResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewPullRequestResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *PullRequestStore) MustFind(q *PullRequestQuery) *PullRequestResultSet {
	return NewPullRequestResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *PullRequestStore) Count(q *PullRequestQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *PullRequestStore) MustCount(q *PullRequestQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *PullRequestStore) FindOne(q *PullRequestQuery) (*PullRequest, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *PullRequestStore) FindAll(q *PullRequestQuery) ([]*PullRequest, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *PullRequestStore) MustFindOne(q *PullRequestQuery) *PullRequest {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the PullRequest with the data in the database and
// makes it writable.
func (s *PullRequestStore) Reload(record *PullRequest) error {
	return s.Store.Reload(Schema.PullRequest.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *PullRequestStore) Transaction(callback func(*PullRequestStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&PullRequestStore{store})
	})
}

// PullRequestQuery is the object used to create queries for the PullRequest
// entity.
type PullRequestQuery struct {
	*kallax.BaseQuery
}

// NewPullRequestQuery returns a new instance of PullRequestQuery.
func NewPullRequestQuery() *PullRequestQuery {
	return &PullRequestQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.PullRequest.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *PullRequestQuery) Select(columns ...kallax.SchemaField) *PullRequestQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *PullRequestQuery) SelectNot(columns ...kallax.SchemaField) *PullRequestQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *PullRequestQuery) Copy() *PullRequestQuery {
	return &PullRequestQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *PullRequestQuery) Order(cols ...kallax.ColumnOrder) *PullRequestQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *PullRequestQuery) BatchSize(size uint64) *PullRequestQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *PullRequestQuery) Limit(n uint64) *PullRequestQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *PullRequestQuery) Offset(n uint64) *PullRequestQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *PullRequestQuery) Where(cond kallax.Condition) *PullRequestQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByCreatedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.CreatedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByUpdatedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.UpdatedAt, v))
}

// FindByClosedAt adds a new filter to the query that will require that
// the ClosedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByClosedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.ClosedAt, v))
}

// FindByMergedAt adds a new filter to the query that will require that
// the MergedAt property is equal to the passed value.
func (q *PullRequestQuery) FindByMergedAt(cond kallax.ScalarCond, v time.Time) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.MergedAt, v))
}

// FindByRepositoryOwner adds a new filter to the query that will require that
// the RepositoryOwner property is equal to the passed value.
func (q *PullRequestQuery) FindByRepositoryOwner(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.RepositoryOwner, v))
}

// FindByRepositoryName adds a new filter to the query that will require that
// the RepositoryName property is equal to the passed value.
func (q *PullRequestQuery) FindByRepositoryName(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.RepositoryName, v))
}

// FindByLabelList adds a new filter to the query that will require that
// the LabelList property contains all the passed values; if no passed values,
// it will do nothing.
func (q *PullRequestQuery) FindByLabelList(v ...string) *PullRequestQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.PullRequest.LabelList, values...))
}

// FindByUserID adds a new filter to the query that will require that
// the UserID property is equal to the passed value.
func (q *PullRequestQuery) FindByUserID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.UserID, v))
}

// FindByUserLogin adds a new filter to the query that will require that
// the UserLogin property is equal to the passed value.
func (q *PullRequestQuery) FindByUserLogin(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.UserLogin, v))
}

// FindByMergedByID adds a new filter to the query that will require that
// the MergedByID property is equal to the passed value.
func (q *PullRequestQuery) FindByMergedByID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.MergedByID, v))
}

// FindByMergedByLogin adds a new filter to the query that will require that
// the MergedByLogin property is equal to the passed value.
func (q *PullRequestQuery) FindByMergedByLogin(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.MergedByLogin, v))
}

// FindByAssigneeID adds a new filter to the query that will require that
// the AssigneeID property is equal to the passed value.
func (q *PullRequestQuery) FindByAssigneeID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.AssigneeID, v))
}

// FindByAssigneeLogin adds a new filter to the query that will require that
// the AssigneeLogin property is equal to the passed value.
func (q *PullRequestQuery) FindByAssigneeLogin(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.AssigneeLogin, v))
}

// FindByMilestoneID adds a new filter to the query that will require that
// the MilestoneID property is equal to the passed value.
func (q *PullRequestQuery) FindByMilestoneID(cond kallax.ScalarCond, v int64) *PullRequestQuery {
	return q.Where(cond(Schema.PullRequest.MilestoneID, v))
}

// FindByMilestoneTitle adds a new filter to the query that will require that
// the MilestoneTitle property is equal to the passed value.
func (q *PullRequestQuery) FindByMilestoneTitle(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.MilestoneTitle, v))
}

// FindByHeadSHA adds a new filter to the query that will require that
// the HeadSHA property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadSHA(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadSHA, v))
}

// FindByHeadRef adds a new filter to the query that will require that
// the HeadRef property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadRef(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadRef, v))
}

// FindByHeadLabel adds a new filter to the query that will require that
// the HeadLabel property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadLabel(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadLabel, v))
}

// FindByHeadUser adds a new filter to the query that will require that
// the HeadUser property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadUser(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadUser, v))
}

// FindByHeadRepositoryOwner adds a new filter to the query that will require that
// the HeadRepositoryOwner property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadRepositoryOwner(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadRepositoryOwner, v))
}

// FindByHeadRepositoryName adds a new filter to the query that will require that
// the HeadRepositoryName property is equal to the passed value.
func (q *PullRequestQuery) FindByHeadRepositoryName(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.HeadRepositoryName, v))
}

// FindByBaseSHA adds a new filter to the query that will require that
// the BaseSHA property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseSHA(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseSHA, v))
}

// FindByBaseRef adds a new filter to the query that will require that
// the BaseRef property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseRef(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseRef, v))
}

// FindByBaseLabel adds a new filter to the query that will require that
// the BaseLabel property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseLabel(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseLabel, v))
}

// FindByBaseUser adds a new filter to the query that will require that
// the BaseUser property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseUser(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseUser, v))
}

// FindByBaseRepositoryOwner adds a new filter to the query that will require that
// the BaseRepositoryOwner property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseRepositoryOwner(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseRepositoryOwner, v))
}

// FindByBaseRepositoryName adds a new filter to the query that will require that
// the BaseRepositoryName property is equal to the passed value.
func (q *PullRequestQuery) FindByBaseRepositoryName(v string) *PullRequestQuery {
	return q.Where(kallax.Eq(Schema.PullRequest.BaseRepositoryName, v))
}

// PullRequestResultSet is the set of results returned by a query to the
// database.
type PullRequestResultSet struct {
	ResultSet kallax.ResultSet
	last      *PullRequest
	lastErr   error
}

// NewPullRequestResultSet creates a new result set for rows of the type
// PullRequest.
func NewPullRequestResultSet(rs kallax.ResultSet) *PullRequestResultSet {
	return &PullRequestResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *PullRequestResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.PullRequest.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*PullRequest)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *PullRequest")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *PullRequestResultSet) Get() (*PullRequest, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *PullRequestResultSet) ForEach(fn func(*PullRequest) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *PullRequestResultSet) All() ([]*PullRequest, error) {
	var result []*PullRequest
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *PullRequestResultSet) One() (*PullRequest, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *PullRequestResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *PullRequestResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewRepository returns a new instance of Repository.
func NewRepository() (record *Repository) {
	return new(Repository)
}

// GetID returns the primary key of the model.
func (r *Repository) GetID() kallax.Identifier {
	return (*kallax.NumericID)(r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Repository) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(r.Repository.ID), nil
	case "node_id":
		return types.Nullable(&r.Repository.NodeID), nil
	case "name":
		return types.Nullable(&r.Repository.Name), nil
	case "full_name":
		return types.Nullable(&r.Repository.FullName), nil
	case "description":
		return types.Nullable(&r.Repository.Description), nil
	case "homepage":
		return types.Nullable(&r.Repository.Homepage), nil
	case "code_of_conduct":
		if r.CodeOfConduct == nil {
			r.CodeOfConduct = new(github.CodeOfConduct)
		}
		return types.JSON(r.Repository.CodeOfConduct), nil
	case "default_branch":
		return types.Nullable(&r.Repository.DefaultBranch), nil
	case "master_branch":
		return types.Nullable(&r.Repository.MasterBranch), nil
	case "created_at":
		return (*types.Timestamp)(r.Repository.CreatedAt), nil
	case "pushed_at":
		return (*types.Timestamp)(r.Repository.PushedAt), nil
	case "updated_at":
		return (*types.Timestamp)(r.Repository.UpdatedAt), nil
	case "htmlurl":
		return types.Nullable(&r.Repository.HTMLURL), nil
	case "clone_url":
		return types.Nullable(&r.Repository.CloneURL), nil
	case "git_url":
		return types.Nullable(&r.Repository.GitURL), nil
	case "mirror_url":
		return types.Nullable(&r.Repository.MirrorURL), nil
	case "sshurl":
		return types.Nullable(&r.Repository.SSHURL), nil
	case "svnurl":
		return types.Nullable(&r.Repository.SVNURL), nil
	case "language":
		return types.Nullable(&r.Repository.Language), nil
	case "fork":
		return types.Nullable(&r.Repository.Fork), nil
	case "forks_count":
		return types.Nullable(&r.Repository.ForksCount), nil
	case "network_count":
		return types.Nullable(&r.Repository.NetworkCount), nil
	case "open_issues_count":
		return types.Nullable(&r.Repository.OpenIssuesCount), nil
	case "stargazers_count":
		return types.Nullable(&r.Repository.StargazersCount), nil
	case "subscribers_count":
		return types.Nullable(&r.Repository.SubscribersCount), nil
	case "watchers_count":
		return types.Nullable(&r.Repository.WatchersCount), nil
	case "size":
		return types.Nullable(&r.Repository.Size), nil
	case "auto_init":
		return types.Nullable(&r.Repository.AutoInit), nil
	case "parent":
		if r.Parent == nil {
			r.Parent = new(github.Repository)
		}
		return types.JSON(r.Repository.Parent), nil
	case "source":
		if r.Source == nil {
			r.Source = new(github.Repository)
		}
		return types.JSON(r.Repository.Source), nil
	case "permissions":
		if r.Permissions == nil {
			r.Permissions = new(map[string]bool)
		}
		return types.JSON(r.Repository.Permissions), nil
	case "allow_rebase_merge":
		return types.Nullable(&r.Repository.AllowRebaseMerge), nil
	case "allow_squash_merge":
		return types.Nullable(&r.Repository.AllowSquashMerge), nil
	case "allow_merge_commit":
		return types.Nullable(&r.Repository.AllowMergeCommit), nil
	case "topics":
		return types.Slice(&r.Repository.Topics), nil
	case "archived":
		return types.Nullable(&r.Repository.Archived), nil
	case "disabled":
		return types.Nullable(&r.Repository.Disabled), nil
	case "license":
		if r.License == nil {
			r.License = new(github.License)
		}
		return types.JSON(r.Repository.License), nil
	case "private":
		return types.Nullable(&r.Repository.Private), nil
	case "has_issues":
		return types.Nullable(&r.Repository.HasIssues), nil
	case "has_wiki":
		return types.Nullable(&r.Repository.HasWiki), nil
	case "has_pages":
		return types.Nullable(&r.Repository.HasPages), nil
	case "has_projects":
		return types.Nullable(&r.Repository.HasProjects), nil
	case "has_downloads":
		return types.Nullable(&r.Repository.HasDownloads), nil
	case "license_template":
		return types.Nullable(&r.Repository.LicenseTemplate), nil
	case "gitignore_template":
		return types.Nullable(&r.Repository.GitignoreTemplate), nil
	case "team_id":
		return types.Nullable(&r.Repository.TeamID), nil
	case "url":
		return types.Nullable(&r.Repository.URL), nil
	case "archive_url":
		return types.Nullable(&r.Repository.ArchiveURL), nil
	case "assignees_url":
		return types.Nullable(&r.Repository.AssigneesURL), nil
	case "blobs_url":
		return types.Nullable(&r.Repository.BlobsURL), nil
	case "branches_url":
		return types.Nullable(&r.Repository.BranchesURL), nil
	case "collaborators_url":
		return types.Nullable(&r.Repository.CollaboratorsURL), nil
	case "comments_url":
		return types.Nullable(&r.Repository.CommentsURL), nil
	case "commits_url":
		return types.Nullable(&r.Repository.CommitsURL), nil
	case "compare_url":
		return types.Nullable(&r.Repository.CompareURL), nil
	case "contents_url":
		return types.Nullable(&r.Repository.ContentsURL), nil
	case "contributors_url":
		return types.Nullable(&r.Repository.ContributorsURL), nil
	case "deployments_url":
		return types.Nullable(&r.Repository.DeploymentsURL), nil
	case "downloads_url":
		return types.Nullable(&r.Repository.DownloadsURL), nil
	case "events_url":
		return types.Nullable(&r.Repository.EventsURL), nil
	case "forks_url":
		return types.Nullable(&r.Repository.ForksURL), nil
	case "git_commits_url":
		return types.Nullable(&r.Repository.GitCommitsURL), nil
	case "git_refs_url":
		return types.Nullable(&r.Repository.GitRefsURL), nil
	case "git_tags_url":
		return types.Nullable(&r.Repository.GitTagsURL), nil
	case "hooks_url":
		return types.Nullable(&r.Repository.HooksURL), nil
	case "issue_comment_url":
		return types.Nullable(&r.Repository.IssueCommentURL), nil
	case "issue_events_url":
		return types.Nullable(&r.Repository.IssueEventsURL), nil
	case "issues_url":
		return types.Nullable(&r.Repository.IssuesURL), nil
	case "keys_url":
		return types.Nullable(&r.Repository.KeysURL), nil
	case "labels_url":
		return types.Nullable(&r.Repository.LabelsURL), nil
	case "languages_url":
		return types.Nullable(&r.Repository.LanguagesURL), nil
	case "merges_url":
		return types.Nullable(&r.Repository.MergesURL), nil
	case "milestones_url":
		return types.Nullable(&r.Repository.MilestonesURL), nil
	case "notifications_url":
		return types.Nullable(&r.Repository.NotificationsURL), nil
	case "pulls_url":
		return types.Nullable(&r.Repository.PullsURL), nil
	case "releases_url":
		return types.Nullable(&r.Repository.ReleasesURL), nil
	case "stargazers_url":
		return types.Nullable(&r.Repository.StargazersURL), nil
	case "statuses_url":
		return types.Nullable(&r.Repository.StatusesURL), nil
	case "subscribers_url":
		return types.Nullable(&r.Repository.SubscribersURL), nil
	case "subscription_url":
		return types.Nullable(&r.Repository.SubscriptionURL), nil
	case "tags_url":
		return types.Nullable(&r.Repository.TagsURL), nil
	case "trees_url":
		return types.Nullable(&r.Repository.TreesURL), nil
	case "teams_url":
		return types.Nullable(&r.Repository.TeamsURL), nil
	case "owner_id":
		return &r.OwnerID, nil
	case "owner_login":
		return &r.OwnerLogin, nil
	case "organization_id":
		return &r.OrganizationID, nil
	case "organization_name":
		return &r.OrganizationName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Repository: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Repository) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		if r.Repository.ID == (*int64)(nil) {
			return nil, nil
		}
		return r.Repository.ID, nil
	case "node_id":
		if r.Repository.NodeID == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.NodeID, nil
	case "name":
		if r.Repository.Name == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Name, nil
	case "full_name":
		if r.Repository.FullName == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.FullName, nil
	case "description":
		if r.Repository.Description == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Description, nil
	case "homepage":
		if r.Repository.Homepage == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Homepage, nil
	case "code_of_conduct":
		if r.Repository.CodeOfConduct == (*github.CodeOfConduct)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.CodeOfConduct), nil
	case "default_branch":
		if r.Repository.DefaultBranch == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.DefaultBranch, nil
	case "master_branch":
		if r.Repository.MasterBranch == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.MasterBranch, nil
	case "created_at":
		if r.Repository.CreatedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return (*types.Timestamp)(r.Repository.CreatedAt), nil
	case "pushed_at":
		if r.Repository.PushedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return (*types.Timestamp)(r.Repository.PushedAt), nil
	case "updated_at":
		if r.Repository.UpdatedAt == (*github.Timestamp)(nil) {
			return nil, nil
		}
		return (*types.Timestamp)(r.Repository.UpdatedAt), nil
	case "htmlurl":
		if r.Repository.HTMLURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.HTMLURL, nil
	case "clone_url":
		if r.Repository.CloneURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.CloneURL, nil
	case "git_url":
		if r.Repository.GitURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitURL, nil
	case "mirror_url":
		if r.Repository.MirrorURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.MirrorURL, nil
	case "sshurl":
		if r.Repository.SSHURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.SSHURL, nil
	case "svnurl":
		if r.Repository.SVNURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.SVNURL, nil
	case "language":
		if r.Repository.Language == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.Language, nil
	case "fork":
		if r.Repository.Fork == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Fork, nil
	case "forks_count":
		if r.Repository.ForksCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.ForksCount, nil
	case "network_count":
		if r.Repository.NetworkCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.NetworkCount, nil
	case "open_issues_count":
		if r.Repository.OpenIssuesCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.OpenIssuesCount, nil
	case "stargazers_count":
		if r.Repository.StargazersCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.StargazersCount, nil
	case "subscribers_count":
		if r.Repository.SubscribersCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.SubscribersCount, nil
	case "watchers_count":
		if r.Repository.WatchersCount == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.WatchersCount, nil
	case "size":
		if r.Repository.Size == (*int)(nil) {
			return nil, nil
		}
		return r.Repository.Size, nil
	case "auto_init":
		if r.Repository.AutoInit == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AutoInit, nil
	case "parent":
		if r.Repository.Parent == (*github.Repository)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.Parent), nil
	case "source":
		if r.Repository.Source == (*github.Repository)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.Source), nil
	case "permissions":
		if r.Repository.Permissions == (*map[string]bool)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.Permissions), nil
	case "allow_rebase_merge":
		if r.Repository.AllowRebaseMerge == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AllowRebaseMerge, nil
	case "allow_squash_merge":
		if r.Repository.AllowSquashMerge == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AllowSquashMerge, nil
	case "allow_merge_commit":
		if r.Repository.AllowMergeCommit == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.AllowMergeCommit, nil
	case "topics":
		return types.Slice(r.Repository.Topics), nil
	case "archived":
		if r.Repository.Archived == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Archived, nil
	case "disabled":
		if r.Repository.Disabled == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Disabled, nil
	case "license":
		if r.Repository.License == (*github.License)(nil) {
			return nil, nil
		}
		return types.JSON(r.Repository.License), nil
	case "private":
		if r.Repository.Private == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.Private, nil
	case "has_issues":
		if r.Repository.HasIssues == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasIssues, nil
	case "has_wiki":
		if r.Repository.HasWiki == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasWiki, nil
	case "has_pages":
		if r.Repository.HasPages == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasPages, nil
	case "has_projects":
		if r.Repository.HasProjects == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasProjects, nil
	case "has_downloads":
		if r.Repository.HasDownloads == (*bool)(nil) {
			return nil, nil
		}
		return r.Repository.HasDownloads, nil
	case "license_template":
		if r.Repository.LicenseTemplate == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.LicenseTemplate, nil
	case "gitignore_template":
		if r.Repository.GitignoreTemplate == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitignoreTemplate, nil
	case "team_id":
		if r.Repository.TeamID == (*int64)(nil) {
			return nil, nil
		}
		return r.Repository.TeamID, nil
	case "url":
		if r.Repository.URL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.URL, nil
	case "archive_url":
		if r.Repository.ArchiveURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.ArchiveURL, nil
	case "assignees_url":
		if r.Repository.AssigneesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.AssigneesURL, nil
	case "blobs_url":
		if r.Repository.BlobsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.BlobsURL, nil
	case "branches_url":
		if r.Repository.BranchesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.BranchesURL, nil
	case "collaborators_url":
		if r.Repository.CollaboratorsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.CollaboratorsURL, nil
	case "comments_url":
		if r.Repository.CommentsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.CommentsURL, nil
	case "commits_url":
		if r.Repository.CommitsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.CommitsURL, nil
	case "compare_url":
		if r.Repository.CompareURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.CompareURL, nil
	case "contents_url":
		if r.Repository.ContentsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.ContentsURL, nil
	case "contributors_url":
		if r.Repository.ContributorsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.ContributorsURL, nil
	case "deployments_url":
		if r.Repository.DeploymentsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.DeploymentsURL, nil
	case "downloads_url":
		if r.Repository.DownloadsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.DownloadsURL, nil
	case "events_url":
		if r.Repository.EventsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.EventsURL, nil
	case "forks_url":
		if r.Repository.ForksURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.ForksURL, nil
	case "git_commits_url":
		if r.Repository.GitCommitsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitCommitsURL, nil
	case "git_refs_url":
		if r.Repository.GitRefsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitRefsURL, nil
	case "git_tags_url":
		if r.Repository.GitTagsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.GitTagsURL, nil
	case "hooks_url":
		if r.Repository.HooksURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.HooksURL, nil
	case "issue_comment_url":
		if r.Repository.IssueCommentURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.IssueCommentURL, nil
	case "issue_events_url":
		if r.Repository.IssueEventsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.IssueEventsURL, nil
	case "issues_url":
		if r.Repository.IssuesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.IssuesURL, nil
	case "keys_url":
		if r.Repository.KeysURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.KeysURL, nil
	case "labels_url":
		if r.Repository.LabelsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.LabelsURL, nil
	case "languages_url":
		if r.Repository.LanguagesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.LanguagesURL, nil
	case "merges_url":
		if r.Repository.MergesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.MergesURL, nil
	case "milestones_url":
		if r.Repository.MilestonesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.MilestonesURL, nil
	case "notifications_url":
		if r.Repository.NotificationsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.NotificationsURL, nil
	case "pulls_url":
		if r.Repository.PullsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.PullsURL, nil
	case "releases_url":
		if r.Repository.ReleasesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.ReleasesURL, nil
	case "stargazers_url":
		if r.Repository.StargazersURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.StargazersURL, nil
	case "statuses_url":
		if r.Repository.StatusesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.StatusesURL, nil
	case "subscribers_url":
		if r.Repository.SubscribersURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.SubscribersURL, nil
	case "subscription_url":
		if r.Repository.SubscriptionURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.SubscriptionURL, nil
	case "tags_url":
		if r.Repository.TagsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.TagsURL, nil
	case "trees_url":
		if r.Repository.TreesURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.TreesURL, nil
	case "teams_url":
		if r.Repository.TeamsURL == (*string)(nil) {
			return nil, nil
		}
		return r.Repository.TeamsURL, nil
	case "owner_id":
		return r.OwnerID, nil
	case "owner_login":
		return r.OwnerLogin, nil
	case "organization_id":
		return r.OrganizationID, nil
	case "organization_name":
		return r.OrganizationName, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Repository: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Repository) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Repository has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Repository) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Repository has no relationships")
}

// RepositoryStore is the entity to access the records of the type Repository
// in the database.
type RepositoryStore struct {
	*kallax.Store
}

// NewRepositoryStore creates a new instance of RepositoryStore
// using a SQL database.
func NewRepositoryStore(db *sql.DB) *RepositoryStore {
	return &RepositoryStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *RepositoryStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *RepositoryStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *RepositoryStore) Debug() *RepositoryStore {
	return &RepositoryStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *RepositoryStore) DebugWith(logger kallax.LoggerFunc) *RepositoryStore {
	return &RepositoryStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *RepositoryStore) DisableCacher() *RepositoryStore {
	return &RepositoryStore{s.Store.DisableCacher()}
}

// Insert inserts a Repository in the database. A non-persisted object is
// required for this operation.
func (s *RepositoryStore) Insert(record *Repository) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.CreatedAt.Time = record.CreatedAt.Time.Truncate(time.Microsecond)
	record.PushedAt.Time = record.PushedAt.Time.Truncate(time.Microsecond)
	record.UpdatedAt.Time = record.UpdatedAt.Time.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Repository.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *RepositoryStore) Update(record *Repository, cols ...kallax.SchemaField) (updated int64, err error) {
	record.CreatedAt.Time = record.CreatedAt.Time.Truncate(time.Microsecond)
	record.PushedAt.Time = record.PushedAt.Time.Truncate(time.Microsecond)
	record.UpdatedAt.Time = record.UpdatedAt.Time.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Repository.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *RepositoryStore) Save(record *Repository) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *RepositoryStore) Delete(record *Repository) error {
	return s.Store.Delete(Schema.Repository.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *RepositoryStore) Find(q *RepositoryQuery) (*RepositoryResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewRepositoryResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *RepositoryStore) MustFind(q *RepositoryQuery) *RepositoryResultSet {
	return NewRepositoryResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *RepositoryStore) Count(q *RepositoryQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *RepositoryStore) MustCount(q *RepositoryQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *RepositoryStore) FindOne(q *RepositoryQuery) (*Repository, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *RepositoryStore) FindAll(q *RepositoryQuery) ([]*Repository, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *RepositoryStore) MustFindOne(q *RepositoryQuery) *Repository {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Repository with the data in the database and
// makes it writable.
func (s *RepositoryStore) Reload(record *Repository) error {
	return s.Store.Reload(Schema.Repository.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *RepositoryStore) Transaction(callback func(*RepositoryStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&RepositoryStore{store})
	})
}

// RepositoryQuery is the object used to create queries for the Repository
// entity.
type RepositoryQuery struct {
	*kallax.BaseQuery
}

// NewRepositoryQuery returns a new instance of RepositoryQuery.
func NewRepositoryQuery() *RepositoryQuery {
	return &RepositoryQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Repository.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *RepositoryQuery) Select(columns ...kallax.SchemaField) *RepositoryQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *RepositoryQuery) SelectNot(columns ...kallax.SchemaField) *RepositoryQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *RepositoryQuery) Copy() *RepositoryQuery {
	return &RepositoryQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *RepositoryQuery) Order(cols ...kallax.ColumnOrder) *RepositoryQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *RepositoryQuery) BatchSize(size uint64) *RepositoryQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *RepositoryQuery) Limit(n uint64) *RepositoryQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *RepositoryQuery) Offset(n uint64) *RepositoryQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *RepositoryQuery) Where(cond kallax.Condition) *RepositoryQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByCreatedAt adds a new filter to the query that will require that
// the CreatedAt property is equal to the passed value.
func (q *RepositoryQuery) FindByCreatedAt(cond kallax.ScalarCond, v github.Timestamp) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.CreatedAt, v))
}

// FindByPushedAt adds a new filter to the query that will require that
// the PushedAt property is equal to the passed value.
func (q *RepositoryQuery) FindByPushedAt(cond kallax.ScalarCond, v github.Timestamp) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.PushedAt, v))
}

// FindByUpdatedAt adds a new filter to the query that will require that
// the UpdatedAt property is equal to the passed value.
func (q *RepositoryQuery) FindByUpdatedAt(cond kallax.ScalarCond, v github.Timestamp) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.UpdatedAt, v))
}

// FindByTopics adds a new filter to the query that will require that
// the Topics property contains all the passed values; if no passed values,
// it will do nothing.
func (q *RepositoryQuery) FindByTopics(v ...string) *RepositoryQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Repository.Topics, values...))
}

// FindByOwnerID adds a new filter to the query that will require that
// the OwnerID property is equal to the passed value.
func (q *RepositoryQuery) FindByOwnerID(cond kallax.ScalarCond, v int64) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.OwnerID, v))
}

// FindByOwnerLogin adds a new filter to the query that will require that
// the OwnerLogin property is equal to the passed value.
func (q *RepositoryQuery) FindByOwnerLogin(v string) *RepositoryQuery {
	return q.Where(kallax.Eq(Schema.Repository.OwnerLogin, v))
}

// FindByOrganizationID adds a new filter to the query that will require that
// the OrganizationID property is equal to the passed value.
func (q *RepositoryQuery) FindByOrganizationID(cond kallax.ScalarCond, v int64) *RepositoryQuery {
	return q.Where(cond(Schema.Repository.OrganizationID, v))
}

// FindByOrganizationName adds a new filter to the query that will require that
// the OrganizationName property is equal to the passed value.
func (q *RepositoryQuery) FindByOrganizationName(v string) *RepositoryQuery {
	return q.Where(kallax.Eq(Schema.Repository.OrganizationName, v))
}

// RepositoryResultSet is the set of results returned by a query to the
// database.
type RepositoryResultSet struct {
	ResultSet kallax.ResultSet
	last      *Repository
	lastErr   error
}

// NewRepositoryResultSet creates a new result set for rows of the type
// Repository.
func NewRepositoryResultSet(rs kallax.ResultSet) *RepositoryResultSet {
	return &RepositoryResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *RepositoryResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Repository.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Repository)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Repository")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *RepositoryResultSet) Get() (*Repository, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *RepositoryResultSet) ForEach(fn func(*Repository) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *RepositoryResultSet) All() ([]*Repository, error) {
	var result []*Repository
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *RepositoryResultSet) One() (*Repository, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *RepositoryResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *RepositoryResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Issue        *schemaIssue
	Organization *schemaOrganization
	PullRequest  *schemaPullRequest
	Repository   *schemaRepository
}

type schemaIssue struct {
	*kallax.BaseSchema
	ID               kallax.SchemaField
	Number           kallax.SchemaField
	State            kallax.SchemaField
	Locked           kallax.SchemaField
	Title            kallax.SchemaField
	Body             kallax.SchemaField
	Comments         kallax.SchemaField
	ClosedAt         kallax.SchemaField
	CreatedAt        kallax.SchemaField
	UpdatedAt        kallax.SchemaField
	URL              kallax.SchemaField
	HTMLURL          kallax.SchemaField
	CommentsURL      kallax.SchemaField
	EventsURL        kallax.SchemaField
	LabelsURL        kallax.SchemaField
	RepositoryURL    kallax.SchemaField
	Reactions        *schemaIssueReactions
	NodeID           kallax.SchemaField
	ActiveLockReason kallax.SchemaField
	RepositoryOwner  kallax.SchemaField
	RepositoryName   kallax.SchemaField
	LabelList        kallax.SchemaField
	UserID           kallax.SchemaField
	UserLogin        kallax.SchemaField
	AssigneeID       kallax.SchemaField
	AssigneeLogin    kallax.SchemaField
	AssigneesList    *schemaIssueAssigneesList
	ClosedByID       kallax.SchemaField
	ClosedByLogin    kallax.SchemaField
	MilestoneID      kallax.SchemaField
	MilestoneTitle   kallax.SchemaField
	PullRequestURL   kallax.SchemaField
}

type schemaOrganization struct {
	*kallax.BaseSchema
	ID                          kallax.SchemaField
	Login                       kallax.SchemaField
	NodeID                      kallax.SchemaField
	AvatarURL                   kallax.SchemaField
	HTMLURL                     kallax.SchemaField
	Name                        kallax.SchemaField
	Company                     kallax.SchemaField
	Blog                        kallax.SchemaField
	Location                    kallax.SchemaField
	Email                       kallax.SchemaField
	Description                 kallax.SchemaField
	PublicRepos                 kallax.SchemaField
	PublicGists                 kallax.SchemaField
	Followers                   kallax.SchemaField
	Following                   kallax.SchemaField
	CreatedAt                   kallax.SchemaField
	UpdatedAt                   kallax.SchemaField
	TotalPrivateRepos           kallax.SchemaField
	OwnedPrivateRepos           kallax.SchemaField
	PrivateGists                kallax.SchemaField
	DiskUsage                   kallax.SchemaField
	Collaborators               kallax.SchemaField
	BillingEmail                kallax.SchemaField
	Type                        kallax.SchemaField
	Plan                        *schemaOrganizationPlan
	TwoFactorRequirementEnabled kallax.SchemaField
	DefaultRepoPermission       kallax.SchemaField
	DefaultRepoSettings         kallax.SchemaField
	MembersCanCreateRepos       kallax.SchemaField
	URL                         kallax.SchemaField
	EventsURL                   kallax.SchemaField
	HooksURL                    kallax.SchemaField
	IssuesURL                   kallax.SchemaField
	MembersURL                  kallax.SchemaField
	PublicMembersURL            kallax.SchemaField
	ReposURL                    kallax.SchemaField
}

type schemaPullRequest struct {
	*kallax.BaseSchema
	ID                     kallax.SchemaField
	Number                 kallax.SchemaField
	State                  kallax.SchemaField
	Title                  kallax.SchemaField
	Body                   kallax.SchemaField
	CreatedAt              kallax.SchemaField
	UpdatedAt              kallax.SchemaField
	ClosedAt               kallax.SchemaField
	MergedAt               kallax.SchemaField
	Draft                  kallax.SchemaField
	Merged                 kallax.SchemaField
	Mergeable              kallax.SchemaField
	MergeableState         kallax.SchemaField
	MergeCommitSHA         kallax.SchemaField
	Comments               kallax.SchemaField
	Commits                kallax.SchemaField
	Additions              kallax.SchemaField
	Deletions              kallax.SchemaField
	ChangedFiles           kallax.SchemaField
	URL                    kallax.SchemaField
	HTMLURL                kallax.SchemaField
	IssueURL               kallax.SchemaField
	StatusesURL            kallax.SchemaField
	DiffURL                kallax.SchemaField
	PatchURL               kallax.SchemaField
	CommitsURL             kallax.SchemaField
	CommentsURL            kallax.SchemaField
	ReviewCommentsURL      kallax.SchemaField
	ReviewCommentURL       kallax.SchemaField
	ReviewComments         kallax.SchemaField
	MaintainerCanModify    kallax.SchemaField
	AuthorAssociation      kallax.SchemaField
	NodeID                 kallax.SchemaField
	RepositoryOwner        kallax.SchemaField
	RepositoryName         kallax.SchemaField
	LabelList              kallax.SchemaField
	UserID                 kallax.SchemaField
	UserLogin              kallax.SchemaField
	MergedByID             kallax.SchemaField
	MergedByLogin          kallax.SchemaField
	AssigneeID             kallax.SchemaField
	AssigneeLogin          kallax.SchemaField
	AssigneesList          *schemaPullRequestAssigneesList
	RequestedReviewersList *schemaPullRequestRequestedReviewersList
	MilestoneID            kallax.SchemaField
	MilestoneTitle         kallax.SchemaField
	HeadSHA                kallax.SchemaField
	HeadRef                kallax.SchemaField
	HeadLabel              kallax.SchemaField
	HeadUser               kallax.SchemaField
	HeadRepositoryOwner    kallax.SchemaField
	HeadRepositoryName     kallax.SchemaField
	BaseSHA                kallax.SchemaField
	BaseRef                kallax.SchemaField
	BaseLabel              kallax.SchemaField
	BaseUser               kallax.SchemaField
	BaseRepositoryOwner    kallax.SchemaField
	BaseRepositoryName     kallax.SchemaField
}

type schemaRepository struct {
	*kallax.BaseSchema
	ID                kallax.SchemaField
	NodeID            kallax.SchemaField
	Name              kallax.SchemaField
	FullName          kallax.SchemaField
	Description       kallax.SchemaField
	Homepage          kallax.SchemaField
	CodeOfConduct     *schemaRepositoryCodeOfConduct
	DefaultBranch     kallax.SchemaField
	MasterBranch      kallax.SchemaField
	CreatedAt         kallax.SchemaField
	PushedAt          kallax.SchemaField
	UpdatedAt         kallax.SchemaField
	HTMLURL           kallax.SchemaField
	CloneURL          kallax.SchemaField
	GitURL            kallax.SchemaField
	MirrorURL         kallax.SchemaField
	SSHURL            kallax.SchemaField
	SVNURL            kallax.SchemaField
	Language          kallax.SchemaField
	Fork              kallax.SchemaField
	ForksCount        kallax.SchemaField
	NetworkCount      kallax.SchemaField
	OpenIssuesCount   kallax.SchemaField
	StargazersCount   kallax.SchemaField
	SubscribersCount  kallax.SchemaField
	WatchersCount     kallax.SchemaField
	Size              kallax.SchemaField
	AutoInit          kallax.SchemaField
	Parent            kallax.SchemaField
	Source            kallax.SchemaField
	Permissions       kallax.SchemaField
	AllowRebaseMerge  kallax.SchemaField
	AllowSquashMerge  kallax.SchemaField
	AllowMergeCommit  kallax.SchemaField
	Topics            kallax.SchemaField
	Archived          kallax.SchemaField
	Disabled          kallax.SchemaField
	License           *schemaRepositoryLicense
	Private           kallax.SchemaField
	HasIssues         kallax.SchemaField
	HasWiki           kallax.SchemaField
	HasPages          kallax.SchemaField
	HasProjects       kallax.SchemaField
	HasDownloads      kallax.SchemaField
	LicenseTemplate   kallax.SchemaField
	GitignoreTemplate kallax.SchemaField
	TeamID            kallax.SchemaField
	URL               kallax.SchemaField
	ArchiveURL        kallax.SchemaField
	AssigneesURL      kallax.SchemaField
	BlobsURL          kallax.SchemaField
	BranchesURL       kallax.SchemaField
	CollaboratorsURL  kallax.SchemaField
	CommentsURL       kallax.SchemaField
	CommitsURL        kallax.SchemaField
	CompareURL        kallax.SchemaField
	ContentsURL       kallax.SchemaField
	ContributorsURL   kallax.SchemaField
	DeploymentsURL    kallax.SchemaField
	DownloadsURL      kallax.SchemaField
	EventsURL         kallax.SchemaField
	ForksURL          kallax.SchemaField
	GitCommitsURL     kallax.SchemaField
	GitRefsURL        kallax.SchemaField
	GitTagsURL        kallax.SchemaField
	HooksURL          kallax.SchemaField
	IssueCommentURL   kallax.SchemaField
	IssueEventsURL    kallax.SchemaField
	IssuesURL         kallax.SchemaField
	KeysURL           kallax.SchemaField
	LabelsURL         kallax.SchemaField
	LanguagesURL      kallax.SchemaField
	MergesURL         kallax.SchemaField
	MilestonesURL     kallax.SchemaField
	NotificationsURL  kallax.SchemaField
	PullsURL          kallax.SchemaField
	ReleasesURL       kallax.SchemaField
	StargazersURL     kallax.SchemaField
	StatusesURL       kallax.SchemaField
	SubscribersURL    kallax.SchemaField
	SubscriptionURL   kallax.SchemaField
	TagsURL           kallax.SchemaField
	TreesURL          kallax.SchemaField
	TeamsURL          kallax.SchemaField
	OwnerID           kallax.SchemaField
	OwnerLogin        kallax.SchemaField
	OrganizationID    kallax.SchemaField
	OrganizationName  kallax.SchemaField
}

type schemaIssueAssigneesList struct {
	*kallax.BaseSchemaField
	ID    kallax.SchemaField
	Login kallax.SchemaField
}

func (s *schemaIssueAssigneesList) At(n int) *schemaIssueAssigneesList {
	return &schemaIssueAssigneesList{
		BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
		ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", fmt.Sprint(n), "ID"),
		Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", fmt.Sprint(n), "Login"),
	}
}

type schemaIssueReactions struct {
	*kallax.BaseSchemaField
	TotalCount kallax.SchemaField
	PlusOne    kallax.SchemaField
	MinusOne   kallax.SchemaField
	Laugh      kallax.SchemaField
	Confused   kallax.SchemaField
	Heart      kallax.SchemaField
	Hooray     kallax.SchemaField
	URL        kallax.SchemaField
}

type schemaOrganizationPlan struct {
	*kallax.BaseSchemaField
	Name          kallax.SchemaField
	Space         kallax.SchemaField
	Collaborators kallax.SchemaField
	PrivateRepos  kallax.SchemaField
}

type schemaPullRequestAssigneesList struct {
	*kallax.BaseSchemaField
	ID    kallax.SchemaField
	Login kallax.SchemaField
}

func (s *schemaPullRequestAssigneesList) At(n int) *schemaPullRequestAssigneesList {
	return &schemaPullRequestAssigneesList{
		BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
		ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", fmt.Sprint(n), "ID"),
		Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", fmt.Sprint(n), "Login"),
	}
}

type schemaPullRequestRequestedReviewersList struct {
	*kallax.BaseSchemaField
	ID    kallax.SchemaField
	Login kallax.SchemaField
}

func (s *schemaPullRequestRequestedReviewersList) At(n int) *schemaPullRequestRequestedReviewersList {
	return &schemaPullRequestRequestedReviewersList{
		BaseSchemaField: kallax.NewSchemaField("requested_reviewers").(*kallax.BaseSchemaField),
		ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "requested_reviewers", fmt.Sprint(n), "ID"),
		Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "requested_reviewers", fmt.Sprint(n), "Login"),
	}
}

type schemaRepositoryCodeOfConduct struct {
	*kallax.BaseSchemaField
	Name kallax.SchemaField
	Key  kallax.SchemaField
	URL  kallax.SchemaField
	Body kallax.SchemaField
}

type schemaRepositoryLicense struct {
	*kallax.BaseSchemaField
	Key            kallax.SchemaField
	Name           kallax.SchemaField
	URL            kallax.SchemaField
	SPDXID         kallax.SchemaField
	HTMLURL        kallax.SchemaField
	Featured       kallax.SchemaField
	Description    kallax.SchemaField
	Implementation kallax.SchemaField
	Permissions    kallax.SchemaField
	Conditions     kallax.SchemaField
	Limitations    kallax.SchemaField
	Body           kallax.SchemaField
}

var Schema = &schema{
	Issue: &schemaIssue{
		BaseSchema: kallax.NewBaseSchema(
			"issues",
			"__issue",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Issue)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("number"),
			kallax.NewSchemaField("state"),
			kallax.NewSchemaField("locked"),
			kallax.NewSchemaField("title"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("comments"),
			kallax.NewSchemaField("closed_at"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("url"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("comments_url"),
			kallax.NewSchemaField("events_url"),
			kallax.NewSchemaField("labels_url"),
			kallax.NewSchemaField("repository_url"),
			kallax.NewSchemaField("reactions"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("active_lock_reason"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
			kallax.NewSchemaField("labels"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("assignee_id"),
			kallax.NewSchemaField("assignee_login"),
			kallax.NewSchemaField("assignees"),
			kallax.NewSchemaField("closed_by_id"),
			kallax.NewSchemaField("closed_by_login"),
			kallax.NewSchemaField("milestone_id"),
			kallax.NewSchemaField("milestone_title"),
			kallax.NewSchemaField("pull_request_url"),
		),
		ID:            kallax.NewSchemaField("id"),
		Number:        kallax.NewSchemaField("number"),
		State:         kallax.NewSchemaField("state"),
		Locked:        kallax.NewSchemaField("locked"),
		Title:         kallax.NewSchemaField("title"),
		Body:          kallax.NewSchemaField("body"),
		Comments:      kallax.NewSchemaField("comments"),
		ClosedAt:      kallax.NewSchemaField("closed_at"),
		CreatedAt:     kallax.NewSchemaField("created_at"),
		UpdatedAt:     kallax.NewSchemaField("updated_at"),
		URL:           kallax.NewSchemaField("url"),
		HTMLURL:       kallax.NewSchemaField("htmlurl"),
		CommentsURL:   kallax.NewSchemaField("comments_url"),
		EventsURL:     kallax.NewSchemaField("events_url"),
		LabelsURL:     kallax.NewSchemaField("labels_url"),
		RepositoryURL: kallax.NewSchemaField("repository_url"),
		Reactions: &schemaIssueReactions{
			BaseSchemaField: kallax.NewSchemaField("reactions").(*kallax.BaseSchemaField),
			TotalCount:      kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "total_count"),
			PlusOne:         kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "+1"),
			MinusOne:        kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "-1"),
			Laugh:           kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "laugh"),
			Confused:        kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "confused"),
			Heart:           kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "heart"),
			Hooray:          kallax.NewJSONSchemaKey(kallax.JSONInt, "issue", "reactions", "hooray"),
			URL:             kallax.NewJSONSchemaKey(kallax.JSONText, "issue", "reactions", "url"),
		},
		NodeID:           kallax.NewSchemaField("node_id"),
		ActiveLockReason: kallax.NewSchemaField("active_lock_reason"),
		RepositoryOwner:  kallax.NewSchemaField("repository_owner"),
		RepositoryName:   kallax.NewSchemaField("repository_name"),
		LabelList:        kallax.NewSchemaField("labels"),
		UserID:           kallax.NewSchemaField("user_id"),
		UserLogin:        kallax.NewSchemaField("user_login"),
		AssigneeID:       kallax.NewSchemaField("assignee_id"),
		AssigneeLogin:    kallax.NewSchemaField("assignee_login"),
		AssigneesList: &schemaIssueAssigneesList{
			BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", "ID"),
			Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", "Login"),
		},
		ClosedByID:     kallax.NewSchemaField("closed_by_id"),
		ClosedByLogin:  kallax.NewSchemaField("closed_by_login"),
		MilestoneID:    kallax.NewSchemaField("milestone_id"),
		MilestoneTitle: kallax.NewSchemaField("milestone_title"),
		PullRequestURL: kallax.NewSchemaField("pull_request_url"),
	},
	Organization: &schemaOrganization{
		BaseSchema: kallax.NewBaseSchema(
			"organizations",
			"__organization",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Organization)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("login"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("avatar_url"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("company"),
			kallax.NewSchemaField("blog"),
			kallax.NewSchemaField("location"),
			kallax.NewSchemaField("email"),
			kallax.NewSchemaField("description"),
			kallax.NewSchemaField("public_repos"),
			kallax.NewSchemaField("public_gists"),
			kallax.NewSchemaField("followers"),
			kallax.NewSchemaField("following"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("total_private_repos"),
			kallax.NewSchemaField("owned_private_repos"),
			kallax.NewSchemaField("private_gists"),
			kallax.NewSchemaField("disk_usage"),
			kallax.NewSchemaField("collaborators"),
			kallax.NewSchemaField("billing_email"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("plan"),
			kallax.NewSchemaField("two_factor_requirement_enabled"),
			kallax.NewSchemaField("default_repo_permission"),
			kallax.NewSchemaField("default_repo_settings"),
			kallax.NewSchemaField("members_can_create_repos"),
			kallax.NewSchemaField("url"),
			kallax.NewSchemaField("events_url"),
			kallax.NewSchemaField("hooks_url"),
			kallax.NewSchemaField("issues_url"),
			kallax.NewSchemaField("members_url"),
			kallax.NewSchemaField("public_members_url"),
			kallax.NewSchemaField("repos_url"),
		),
		ID:                kallax.NewSchemaField("id"),
		Login:             kallax.NewSchemaField("login"),
		NodeID:            kallax.NewSchemaField("node_id"),
		AvatarURL:         kallax.NewSchemaField("avatar_url"),
		HTMLURL:           kallax.NewSchemaField("htmlurl"),
		Name:              kallax.NewSchemaField("name"),
		Company:           kallax.NewSchemaField("company"),
		Blog:              kallax.NewSchemaField("blog"),
		Location:          kallax.NewSchemaField("location"),
		Email:             kallax.NewSchemaField("email"),
		Description:       kallax.NewSchemaField("description"),
		PublicRepos:       kallax.NewSchemaField("public_repos"),
		PublicGists:       kallax.NewSchemaField("public_gists"),
		Followers:         kallax.NewSchemaField("followers"),
		Following:         kallax.NewSchemaField("following"),
		CreatedAt:         kallax.NewSchemaField("created_at"),
		UpdatedAt:         kallax.NewSchemaField("updated_at"),
		TotalPrivateRepos: kallax.NewSchemaField("total_private_repos"),
		OwnedPrivateRepos: kallax.NewSchemaField("owned_private_repos"),
		PrivateGists:      kallax.NewSchemaField("private_gists"),
		DiskUsage:         kallax.NewSchemaField("disk_usage"),
		Collaborators:     kallax.NewSchemaField("collaborators"),
		BillingEmail:      kallax.NewSchemaField("billing_email"),
		Type:              kallax.NewSchemaField("type"),
		Plan: &schemaOrganizationPlan{
			BaseSchemaField: kallax.NewSchemaField("plan").(*kallax.BaseSchemaField),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "organization", "plan", "name"),
			Space:           kallax.NewJSONSchemaKey(kallax.JSONInt, "organization", "plan", "space"),
			Collaborators:   kallax.NewJSONSchemaKey(kallax.JSONInt, "organization", "plan", "collaborators"),
			PrivateRepos:    kallax.NewJSONSchemaKey(kallax.JSONInt, "organization", "plan", "private_repos"),
		},
		TwoFactorRequirementEnabled: kallax.NewSchemaField("two_factor_requirement_enabled"),
		DefaultRepoPermission:       kallax.NewSchemaField("default_repo_permission"),
		DefaultRepoSettings:         kallax.NewSchemaField("default_repo_settings"),
		MembersCanCreateRepos:       kallax.NewSchemaField("members_can_create_repos"),
		URL:                         kallax.NewSchemaField("url"),
		EventsURL:                   kallax.NewSchemaField("events_url"),
		HooksURL:                    kallax.NewSchemaField("hooks_url"),
		IssuesURL:                   kallax.NewSchemaField("issues_url"),
		MembersURL:                  kallax.NewSchemaField("members_url"),
		PublicMembersURL:            kallax.NewSchemaField("public_members_url"),
		ReposURL:                    kallax.NewSchemaField("repos_url"),
	},
	PullRequest: &schemaPullRequest{
		BaseSchema: kallax.NewBaseSchema(
			"pull_requests",
			"__pullrequest",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(PullRequest)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("number"),
			kallax.NewSchemaField("state"),
			kallax.NewSchemaField("title"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("closed_at"),
			kallax.NewSchemaField("merged_at"),
			kallax.NewSchemaField("draft"),
			kallax.NewSchemaField("merged"),
			kallax.NewSchemaField("mergeable"),
			kallax.NewSchemaField("mergeable_state"),
			kallax.NewSchemaField("merge_commit_sha"),
			kallax.NewSchemaField("comments"),
			kallax.NewSchemaField("commits"),
			kallax.NewSchemaField("additions"),
			kallax.NewSchemaField("deletions"),
			kallax.NewSchemaField("changed_files"),
			kallax.NewSchemaField("url"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("issue_url"),
			kallax.NewSchemaField("statuses_url"),
			kallax.NewSchemaField("diff_url"),
			kallax.NewSchemaField("patch_url"),
			kallax.NewSchemaField("commits_url"),
			kallax.NewSchemaField("comments_url"),
			kallax.NewSchemaField("review_comments_url"),
			kallax.NewSchemaField("review_comment_url"),
			kallax.NewSchemaField("review_comments"),
			kallax.NewSchemaField("maintainer_can_modify"),
			kallax.NewSchemaField("author_association"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("repository_owner"),
			kallax.NewSchemaField("repository_name"),
			kallax.NewSchemaField("labels"),
			kallax.NewSchemaField("user_id"),
			kallax.NewSchemaField("user_login"),
			kallax.NewSchemaField("merged_by_id"),
			kallax.NewSchemaField("merged_by_login"),
			kallax.NewSchemaField("assignee_id"),
			kallax.NewSchemaField("assignee_login"),
			kallax.NewSchemaField("assignees"),
			kallax.NewSchemaField("requested_reviewers"),
			kallax.NewSchemaField("milestone_id"),
			kallax.NewSchemaField("milestone_title"),
			kallax.NewSchemaField("head_sha"),
			kallax.NewSchemaField("head_ref"),
			kallax.NewSchemaField("head_label"),
			kallax.NewSchemaField("head_user"),
			kallax.NewSchemaField("head_repository_owner"),
			kallax.NewSchemaField("head_repository_name"),
			kallax.NewSchemaField("base_sha"),
			kallax.NewSchemaField("base_ref"),
			kallax.NewSchemaField("base_label"),
			kallax.NewSchemaField("base_user"),
			kallax.NewSchemaField("base_repository_owner"),
			kallax.NewSchemaField("base_repository_name"),
		),
		ID:                  kallax.NewSchemaField("id"),
		Number:              kallax.NewSchemaField("number"),
		State:               kallax.NewSchemaField("state"),
		Title:               kallax.NewSchemaField("title"),
		Body:                kallax.NewSchemaField("body"),
		CreatedAt:           kallax.NewSchemaField("created_at"),
		UpdatedAt:           kallax.NewSchemaField("updated_at"),
		ClosedAt:            kallax.NewSchemaField("closed_at"),
		MergedAt:            kallax.NewSchemaField("merged_at"),
		Draft:               kallax.NewSchemaField("draft"),
		Merged:              kallax.NewSchemaField("merged"),
		Mergeable:           kallax.NewSchemaField("mergeable"),
		MergeableState:      kallax.NewSchemaField("mergeable_state"),
		MergeCommitSHA:      kallax.NewSchemaField("merge_commit_sha"),
		Comments:            kallax.NewSchemaField("comments"),
		Commits:             kallax.NewSchemaField("commits"),
		Additions:           kallax.NewSchemaField("additions"),
		Deletions:           kallax.NewSchemaField("deletions"),
		ChangedFiles:        kallax.NewSchemaField("changed_files"),
		URL:                 kallax.NewSchemaField("url"),
		HTMLURL:             kallax.NewSchemaField("htmlurl"),
		IssueURL:            kallax.NewSchemaField("issue_url"),
		StatusesURL:         kallax.NewSchemaField("statuses_url"),
		DiffURL:             kallax.NewSchemaField("diff_url"),
		PatchURL:            kallax.NewSchemaField("patch_url"),
		CommitsURL:          kallax.NewSchemaField("commits_url"),
		CommentsURL:         kallax.NewSchemaField("comments_url"),
		ReviewCommentsURL:   kallax.NewSchemaField("review_comments_url"),
		ReviewCommentURL:    kallax.NewSchemaField("review_comment_url"),
		ReviewComments:      kallax.NewSchemaField("review_comments"),
		MaintainerCanModify: kallax.NewSchemaField("maintainer_can_modify"),
		AuthorAssociation:   kallax.NewSchemaField("author_association"),
		NodeID:              kallax.NewSchemaField("node_id"),
		RepositoryOwner:     kallax.NewSchemaField("repository_owner"),
		RepositoryName:      kallax.NewSchemaField("repository_name"),
		LabelList:           kallax.NewSchemaField("labels"),
		UserID:              kallax.NewSchemaField("user_id"),
		UserLogin:           kallax.NewSchemaField("user_login"),
		MergedByID:          kallax.NewSchemaField("merged_by_id"),
		MergedByLogin:       kallax.NewSchemaField("merged_by_login"),
		AssigneeID:          kallax.NewSchemaField("assignee_id"),
		AssigneeLogin:       kallax.NewSchemaField("assignee_login"),
		AssigneesList: &schemaPullRequestAssigneesList{
			BaseSchemaField: kallax.NewSchemaField("assignees").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "assignees", "ID"),
			Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "assignees", "Login"),
		},
		RequestedReviewersList: &schemaPullRequestRequestedReviewersList{
			BaseSchemaField: kallax.NewSchemaField("requested_reviewers").(*kallax.BaseSchemaField),
			ID:              kallax.NewJSONSchemaKey(kallax.JSONInt, "requested_reviewers", "ID"),
			Login:           kallax.NewJSONSchemaKey(kallax.JSONText, "requested_reviewers", "Login"),
		},
		MilestoneID:         kallax.NewSchemaField("milestone_id"),
		MilestoneTitle:      kallax.NewSchemaField("milestone_title"),
		HeadSHA:             kallax.NewSchemaField("head_sha"),
		HeadRef:             kallax.NewSchemaField("head_ref"),
		HeadLabel:           kallax.NewSchemaField("head_label"),
		HeadUser:            kallax.NewSchemaField("head_user"),
		HeadRepositoryOwner: kallax.NewSchemaField("head_repository_owner"),
		HeadRepositoryName:  kallax.NewSchemaField("head_repository_name"),
		BaseSHA:             kallax.NewSchemaField("base_sha"),
		BaseRef:             kallax.NewSchemaField("base_ref"),
		BaseLabel:           kallax.NewSchemaField("base_label"),
		BaseUser:            kallax.NewSchemaField("base_user"),
		BaseRepositoryOwner: kallax.NewSchemaField("base_repository_owner"),
		BaseRepositoryName:  kallax.NewSchemaField("base_repository_name"),
	},
	Repository: &schemaRepository{
		BaseSchema: kallax.NewBaseSchema(
			"repositories",
			"__repository",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Repository)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("node_id"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("full_name"),
			kallax.NewSchemaField("description"),
			kallax.NewSchemaField("homepage"),
			kallax.NewSchemaField("code_of_conduct"),
			kallax.NewSchemaField("default_branch"),
			kallax.NewSchemaField("master_branch"),
			kallax.NewSchemaField("created_at"),
			kallax.NewSchemaField("pushed_at"),
			kallax.NewSchemaField("updated_at"),
			kallax.NewSchemaField("htmlurl"),
			kallax.NewSchemaField("clone_url"),
			kallax.NewSchemaField("git_url"),
			kallax.NewSchemaField("mirror_url"),
			kallax.NewSchemaField("sshurl"),
			kallax.NewSchemaField("svnurl"),
			kallax.NewSchemaField("language"),
			kallax.NewSchemaField("fork"),
			kallax.NewSchemaField("forks_count"),
			kallax.NewSchemaField("network_count"),
			kallax.NewSchemaField("open_issues_count"),
			kallax.NewSchemaField("stargazers_count"),
			kallax.NewSchemaField("subscribers_count"),
			kallax.NewSchemaField("watchers_count"),
			kallax.NewSchemaField("size"),
			kallax.NewSchemaField("auto_init"),
			kallax.NewSchemaField("parent"),
			kallax.NewSchemaField("source"),
			kallax.NewSchemaField("permissions"),
			kallax.NewSchemaField("allow_rebase_merge"),
			kallax.NewSchemaField("allow_squash_merge"),
			kallax.NewSchemaField("allow_merge_commit"),
			kallax.NewSchemaField("topics"),
			kallax.NewSchemaField("archived"),
			kallax.NewSchemaField("disabled"),
			kallax.NewSchemaField("license"),
			kallax.NewSchemaField("private"),
			kallax.NewSchemaField("has_issues"),
			kallax.NewSchemaField("has_wiki"),
			kallax.NewSchemaField("has_pages"),
			kallax.NewSchemaField("has_projects"),
			kallax.NewSchemaField("has_downloads"),
			kallax.NewSchemaField("license_template"),
			kallax.NewSchemaField("gitignore_template"),
			kallax.NewSchemaField("team_id"),
			kallax.NewSchemaField("url"),
			kallax.NewSchemaField("archive_url"),
			kallax.NewSchemaField("assignees_url"),
			kallax.NewSchemaField("blobs_url"),
			kallax.NewSchemaField("branches_url"),
			kallax.NewSchemaField("collaborators_url"),
			kallax.NewSchemaField("comments_url"),
			kallax.NewSchemaField("commits_url"),
			kallax.NewSchemaField("compare_url"),
			kallax.NewSchemaField("contents_url"),
			kallax.NewSchemaField("contributors_url"),
			kallax.NewSchemaField("deployments_url"),
			kallax.NewSchemaField("downloads_url"),
			kallax.NewSchemaField("events_url"),
			kallax.NewSchemaField("forks_url"),
			kallax.NewSchemaField("git_commits_url"),
			kallax.NewSchemaField("git_refs_url"),
			kallax.NewSchemaField("git_tags_url"),
			kallax.NewSchemaField("hooks_url"),
			kallax.NewSchemaField("issue_comment_url"),
			kallax.NewSchemaField("issue_events_url"),
			kallax.NewSchemaField("issues_url"),
			kallax.NewSchemaField("keys_url"),
			kallax.NewSchemaField("labels_url"),
			kallax.NewSchemaField("languages_url"),
			kallax.NewSchemaField("merges_url"),
			kallax.NewSchemaField("milestones_url"),
			kallax.NewSchemaField("notifications_url"),
			kallax.NewSchemaField("pulls_url"),
			kallax.NewSchemaField("releases_url"),
			kallax.NewSchemaField("stargazers_url"),
			kallax.NewSchemaField("statuses_url"),
			kallax.NewSchemaField("subscribers_url"),
			kallax.NewSchemaField("subscription_url"),
			kallax.NewSchemaField("tags_url"),
			kallax.NewSchemaField("trees_url"),
			kallax.NewSchemaField("teams_url"),
			kallax.NewSchemaField("owner_id"),
			kallax.NewSchemaField("owner_login"),
			kallax.NewSchemaField("organization_id"),
			kallax.NewSchemaField("organization_name"),
		),
		ID:          kallax.NewSchemaField("id"),
		NodeID:      kallax.NewSchemaField("node_id"),
		Name:        kallax.NewSchemaField("name"),
		FullName:    kallax.NewSchemaField("full_name"),
		Description: kallax.NewSchemaField("description"),
		Homepage:    kallax.NewSchemaField("homepage"),
		CodeOfConduct: &schemaRepositoryCodeOfConduct{
			BaseSchemaField: kallax.NewSchemaField("code_of_conduct").(*kallax.BaseSchemaField),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "name"),
			Key:             kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "key"),
			URL:             kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "url"),
			Body:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "code_of_conduct", "body"),
		},
		DefaultBranch:    kallax.NewSchemaField("default_branch"),
		MasterBranch:     kallax.NewSchemaField("master_branch"),
		CreatedAt:        kallax.NewSchemaField("created_at"),
		PushedAt:         kallax.NewSchemaField("pushed_at"),
		UpdatedAt:        kallax.NewSchemaField("updated_at"),
		HTMLURL:          kallax.NewSchemaField("htmlurl"),
		CloneURL:         kallax.NewSchemaField("clone_url"),
		GitURL:           kallax.NewSchemaField("git_url"),
		MirrorURL:        kallax.NewSchemaField("mirror_url"),
		SSHURL:           kallax.NewSchemaField("sshurl"),
		SVNURL:           kallax.NewSchemaField("svnurl"),
		Language:         kallax.NewSchemaField("language"),
		Fork:             kallax.NewSchemaField("fork"),
		ForksCount:       kallax.NewSchemaField("forks_count"),
		NetworkCount:     kallax.NewSchemaField("network_count"),
		OpenIssuesCount:  kallax.NewSchemaField("open_issues_count"),
		StargazersCount:  kallax.NewSchemaField("stargazers_count"),
		SubscribersCount: kallax.NewSchemaField("subscribers_count"),
		WatchersCount:    kallax.NewSchemaField("watchers_count"),
		Size:             kallax.NewSchemaField("size"),
		AutoInit:         kallax.NewSchemaField("auto_init"),
		Parent:           kallax.NewSchemaField("parent"),
		Source:           kallax.NewSchemaField("source"),
		Permissions:      kallax.NewSchemaField("permissions"),
		AllowRebaseMerge: kallax.NewSchemaField("allow_rebase_merge"),
		AllowSquashMerge: kallax.NewSchemaField("allow_squash_merge"),
		AllowMergeCommit: kallax.NewSchemaField("allow_merge_commit"),
		Topics:           kallax.NewSchemaField("topics"),
		Archived:         kallax.NewSchemaField("archived"),
		Disabled:         kallax.NewSchemaField("disabled"),
		License: &schemaRepositoryLicense{
			BaseSchemaField: kallax.NewSchemaField("license").(*kallax.BaseSchemaField),
			Key:             kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "key"),
			Name:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "name"),
			URL:             kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "url"),
			SPDXID:          kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "spdx_id"),
			HTMLURL:         kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "html_url"),
			Featured:        kallax.NewJSONSchemaKey(kallax.JSONBool, "repository", "license", "featured"),
			Description:     kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "description"),
			Implementation:  kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "implementation"),
			Permissions:     kallax.NewJSONSchemaKey(kallax.JSONAny, "repository", "license", "permissions"),
			Conditions:      kallax.NewJSONSchemaKey(kallax.JSONAny, "repository", "license", "conditions"),
			Limitations:     kallax.NewJSONSchemaKey(kallax.JSONAny, "repository", "license", "limitations"),
			Body:            kallax.NewJSONSchemaKey(kallax.JSONText, "repository", "license", "body"),
		},
		Private:           kallax.NewSchemaField("private"),
		HasIssues:         kallax.NewSchemaField("has_issues"),
		HasWiki:           kallax.NewSchemaField("has_wiki"),
		HasPages:          kallax.NewSchemaField("has_pages"),
		HasProjects:       kallax.NewSchemaField("has_projects"),
		HasDownloads:      kallax.NewSchemaField("has_downloads"),
		LicenseTemplate:   kallax.NewSchemaField("license_template"),
		GitignoreTemplate: kallax.NewSchemaField("gitignore_template"),
		TeamID:            kallax.NewSchemaField("team_id"),
		URL:               kallax.NewSchemaField("url"),
		ArchiveURL:        kallax.NewSchemaField("archive_url"),
		AssigneesURL:      kallax.NewSchemaField("assignees_url"),
		BlobsURL:          kallax.NewSchemaField("blobs_url"),
		BranchesURL:       kallax.NewSchemaField("branches_url"),
		CollaboratorsURL:  kallax.NewSchemaField("collaborators_url"),
		CommentsURL:       kallax.NewSchemaField("comments_url"),
		CommitsURL:        kallax.NewSchemaField("commits_url"),
		CompareURL:        kallax.NewSchemaField("compare_url"),
		ContentsURL:       kallax.NewSchemaField("contents_url"),
		ContributorsURL:   kallax.NewSchemaField("contributors_url"),
		DeploymentsURL:    kallax.NewSchemaField("deployments_url"),
		DownloadsURL:      kallax.NewSchemaField("downloads_url"),
		EventsURL:         kallax.NewSchemaField("events_url"),
		ForksURL:          kallax.NewSchemaField("forks_url"),
		GitCommitsURL:     kallax.NewSchemaField("git_commits_url"),
		GitRefsURL:        kallax.NewSchemaField("git_refs_url"),
		GitTagsURL:        kallax.NewSchemaField("git_tags_url"),
		HooksURL:          kallax.NewSchemaField("hooks_url"),
		IssueCommentURL:   kallax.NewSchemaField("issue_comment_url"),
		IssueEventsURL:    kallax.NewSchemaField("issue_events_url"),
		IssuesURL:         kallax.NewSchemaField("issues_url"),
		KeysURL:           kallax.NewSchemaField("keys_url"),
		LabelsURL:         kallax.NewSchemaField("labels_url"),
		LanguagesURL:      kallax.NewSchemaField("languages_url"),
		MergesURL:         kallax.NewSchemaField("merges_url"),
		MilestonesURL:     kallax.NewSchemaField("milestones_url"),
		NotificationsURL:  kallax.NewSchemaField("notifications_url"),
		PullsURL:          kallax.NewSchemaField("pulls_url"),
		ReleasesURL:       kallax.NewSchemaField("releases_url"),
		StargazersURL:     kallax.NewSchemaField("stargazers_url"),
		StatusesURL:       kallax.NewSchemaField("statuses_url"),
		SubscribersURL:    kallax.NewSchemaField("subscribers_url"),
		SubscriptionURL:   kallax.NewSchemaField("subscription_url"),
		TagsURL:           kallax.NewSchemaField("tags_url"),
		TreesURL:          kallax.NewSchemaField("trees_url"),
		TeamsURL:          kallax.NewSchemaField("teams_url"),
		OwnerID:           kallax.NewSchemaField("owner_id"),
		OwnerLogin:        kallax.NewSchemaField("owner_login"),
		OrganizationID:    kallax.NewSchemaField("organization_id"),
		OrganizationName:  kallax.NewSchemaField("organization_name"),
	},
}
