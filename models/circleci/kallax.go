// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package circleci

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/jszwedko/go-circleci"
	"gopkg.in/src-d/go-kallax.v1"
	"gopkg.in/src-d/go-kallax.v1/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewBuild returns a new instance of Build.
func NewBuild() (record *Build) {
	return new(Build)
}

// GetID returns the primary key of the model.
func (r *Build) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Build) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(&r.ID), nil
	case "author_date":
		return types.Nullable(&r.Build.AuthorDate), nil
	case "author_email":
		return &r.Build.AuthorEmail, nil
	case "author_name":
		return &r.Build.AuthorName, nil
	case "body":
		return &r.Build.Body, nil
	case "branch":
		return &r.Build.Branch, nil
	case "build_num":
		return &r.Build.BuildNum, nil
	case "build_parameters":
		return types.JSON(&r.Build.BuildParameters), nil
	case "build_time_millis":
		return types.Nullable(&r.Build.BuildTimeMillis), nil
	case "build_url":
		return &r.Build.BuildURL, nil
	case "canceled":
		return &r.Build.Canceled, nil
	case "circle_yml":
		if r.CircleYML == nil {
			r.CircleYML = new(circleci.CircleYML)
		}
		return types.JSON(r.Build.CircleYML), nil
	case "committer_date":
		return types.Nullable(&r.Build.CommitterDate), nil
	case "committer_email":
		return &r.Build.CommitterEmail, nil
	case "committer_name":
		return &r.Build.CommitterName, nil
	case "compare":
		return types.Nullable(&r.Build.Compare), nil
	case "dont_build":
		return types.Nullable(&r.Build.DontBuild), nil
	case "failed":
		return types.Nullable(&r.Build.Failed), nil
	case "feature_flags":
		return types.JSON(&r.Build.FeatureFlags), nil
	case "infrastructure_fail":
		return &r.Build.InfrastructureFail, nil
	case "is_first_green_build":
		return &r.Build.IsFirstGreenBuild, nil
	case "job_name":
		return types.Nullable(&r.Build.JobName), nil
	case "lifecycle":
		return &r.Build.Lifecycle, nil
	case "oss":
		return &r.Build.OSS, nil
	case "outcome":
		return &r.Build.Outcome, nil
	case "parallel":
		return &r.Build.Parallel, nil
	case "platform":
		return &r.Build.Platform, nil
	case "queued_at":
		return &r.Build.QueuedAt, nil
	case "reponame":
		return &r.Build.Reponame, nil
	case "retries":
		return types.Slice(&r.Build.Retries), nil
	case "retry_of":
		return types.Nullable(&r.Build.RetryOf), nil
	case "start_time":
		return types.Nullable(&r.Build.StartTime), nil
	case "status":
		return &r.Build.Status, nil
	case "stop_time":
		return types.Nullable(&r.Build.StopTime), nil
	case "subject":
		return &r.Build.Subject, nil
	case "timedout":
		return &r.Build.Timedout, nil
	case "usage_queued_at":
		return &r.Build.UsageQueuedAt, nil
	case "username":
		return &r.Build.Username, nil
	case "vcs_revision":
		return &r.Build.VcsRevision, nil
	case "vcs_tag":
		return &r.Build.VcsTag, nil
	case "vcsurl":
		return &r.Build.VCSURL, nil
	case "why":
		return &r.Build.Why, nil
	case "previous_build_num":
		return &r.PreviousBuildNum, nil
	case "previous_successful_build_num":
		return &r.PreviousSuccessfulBuildNum, nil
	case "pull_request_urls":
		return types.Slice(&r.PullRequestURLs), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Build: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Build) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "author_date":
		if r.Build.AuthorDate == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Build.AuthorDate, nil
	case "author_email":
		return r.Build.AuthorEmail, nil
	case "author_name":
		return r.Build.AuthorName, nil
	case "body":
		return r.Build.Body, nil
	case "branch":
		return r.Build.Branch, nil
	case "build_num":
		return r.Build.BuildNum, nil
	case "build_parameters":
		return types.JSON(r.Build.BuildParameters), nil
	case "build_time_millis":
		if r.Build.BuildTimeMillis == (*int)(nil) {
			return nil, nil
		}
		return r.Build.BuildTimeMillis, nil
	case "build_url":
		return r.Build.BuildURL, nil
	case "canceled":
		return r.Build.Canceled, nil
	case "circle_yml":
		if r.Build.CircleYML == (*circleci.CircleYML)(nil) {
			return nil, nil
		}
		return types.JSON(r.Build.CircleYML), nil
	case "committer_date":
		if r.Build.CommitterDate == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Build.CommitterDate, nil
	case "committer_email":
		return r.Build.CommitterEmail, nil
	case "committer_name":
		return r.Build.CommitterName, nil
	case "compare":
		if r.Build.Compare == (*string)(nil) {
			return nil, nil
		}
		return r.Build.Compare, nil
	case "dont_build":
		if r.Build.DontBuild == (*string)(nil) {
			return nil, nil
		}
		return r.Build.DontBuild, nil
	case "failed":
		if r.Build.Failed == (*bool)(nil) {
			return nil, nil
		}
		return r.Build.Failed, nil
	case "feature_flags":
		return types.JSON(r.Build.FeatureFlags), nil
	case "infrastructure_fail":
		return r.Build.InfrastructureFail, nil
	case "is_first_green_build":
		return r.Build.IsFirstGreenBuild, nil
	case "job_name":
		if r.Build.JobName == (*string)(nil) {
			return nil, nil
		}
		return r.Build.JobName, nil
	case "lifecycle":
		return r.Build.Lifecycle, nil
	case "oss":
		return r.Build.OSS, nil
	case "outcome":
		return r.Build.Outcome, nil
	case "parallel":
		return r.Build.Parallel, nil
	case "platform":
		return r.Build.Platform, nil
	case "queued_at":
		return r.Build.QueuedAt, nil
	case "reponame":
		return r.Build.Reponame, nil
	case "retries":
		return types.Slice(r.Build.Retries), nil
	case "retry_of":
		if r.Build.RetryOf == (*int)(nil) {
			return nil, nil
		}
		return r.Build.RetryOf, nil
	case "start_time":
		if r.Build.StartTime == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Build.StartTime, nil
	case "status":
		return r.Build.Status, nil
	case "stop_time":
		if r.Build.StopTime == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Build.StopTime, nil
	case "subject":
		return r.Build.Subject, nil
	case "timedout":
		return r.Build.Timedout, nil
	case "usage_queued_at":
		return r.Build.UsageQueuedAt, nil
	case "username":
		return r.Build.Username, nil
	case "vcs_revision":
		return r.Build.VcsRevision, nil
	case "vcs_tag":
		return r.Build.VcsTag, nil
	case "vcsurl":
		return r.Build.VCSURL, nil
	case "why":
		return r.Build.Why, nil
	case "previous_build_num":
		return r.PreviousBuildNum, nil
	case "previous_successful_build_num":
		return r.PreviousSuccessfulBuildNum, nil
	case "pull_request_urls":
		return types.Slice(r.PullRequestURLs), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Build: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Build) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Build has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Build) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Build has no relationships")
}

// BuildStore is the entity to access the records of the type Build
// in the database.
type BuildStore struct {
	*kallax.Store
}

// NewBuildStore creates a new instance of BuildStore
// using a SQL database.
func NewBuildStore(db *sql.DB) *BuildStore {
	return &BuildStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *BuildStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *BuildStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *BuildStore) Debug() *BuildStore {
	return &BuildStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *BuildStore) DebugWith(logger kallax.LoggerFunc) *BuildStore {
	return &BuildStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *BuildStore) DisableCacher() *BuildStore {
	return &BuildStore{s.Store.DisableCacher()}
}

// Insert inserts a Build in the database. A non-persisted object is
// required for this operation.
func (s *BuildStore) Insert(record *Build) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.AuthorDate != nil {
		record.AuthorDate = func(t time.Time) *time.Time { return &t }(record.AuthorDate.Truncate(time.Microsecond))
	}
	if record.CommitterDate != nil {
		record.CommitterDate = func(t time.Time) *time.Time { return &t }(record.CommitterDate.Truncate(time.Microsecond))
	}
	if record.StartTime != nil {
		record.StartTime = func(t time.Time) *time.Time { return &t }(record.StartTime.Truncate(time.Microsecond))
	}
	if record.StopTime != nil {
		record.StopTime = func(t time.Time) *time.Time { return &t }(record.StopTime.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Build.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *BuildStore) Update(record *Build, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.AuthorDate != nil {
		record.AuthorDate = func(t time.Time) *time.Time { return &t }(record.AuthorDate.Truncate(time.Microsecond))
	}
	if record.CommitterDate != nil {
		record.CommitterDate = func(t time.Time) *time.Time { return &t }(record.CommitterDate.Truncate(time.Microsecond))
	}
	if record.StartTime != nil {
		record.StartTime = func(t time.Time) *time.Time { return &t }(record.StartTime.Truncate(time.Microsecond))
	}
	if record.StopTime != nil {
		record.StopTime = func(t time.Time) *time.Time { return &t }(record.StopTime.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Build.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *BuildStore) Save(record *Build) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *BuildStore) Delete(record *Build) error {
	return s.Store.Delete(Schema.Build.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *BuildStore) Find(q *BuildQuery) (*BuildResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewBuildResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *BuildStore) MustFind(q *BuildQuery) *BuildResultSet {
	return NewBuildResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *BuildStore) Count(q *BuildQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *BuildStore) MustCount(q *BuildQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *BuildStore) FindOne(q *BuildQuery) (*Build, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *BuildStore) FindAll(q *BuildQuery) ([]*Build, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *BuildStore) MustFindOne(q *BuildQuery) *Build {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Build with the data in the database and
// makes it writable.
func (s *BuildStore) Reload(record *Build) error {
	return s.Store.Reload(Schema.Build.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *BuildStore) Transaction(callback func(*BuildStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&BuildStore{store})
	})
}

// BuildQuery is the object used to create queries for the Build
// entity.
type BuildQuery struct {
	*kallax.BaseQuery
}

// NewBuildQuery returns a new instance of BuildQuery.
func NewBuildQuery() *BuildQuery {
	return &BuildQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Build.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *BuildQuery) Select(columns ...kallax.SchemaField) *BuildQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *BuildQuery) SelectNot(columns ...kallax.SchemaField) *BuildQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *BuildQuery) Copy() *BuildQuery {
	return &BuildQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *BuildQuery) Order(cols ...kallax.ColumnOrder) *BuildQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *BuildQuery) BatchSize(size uint64) *BuildQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *BuildQuery) Limit(n uint64) *BuildQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *BuildQuery) Offset(n uint64) *BuildQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *BuildQuery) Where(cond kallax.Condition) *BuildQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *BuildQuery) FindByID(v ...int64) *BuildQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Build.ID, values...))
}

// FindByAuthorDate adds a new filter to the query that will require that
// the AuthorDate property is equal to the passed value.
func (q *BuildQuery) FindByAuthorDate(cond kallax.ScalarCond, v time.Time) *BuildQuery {
	return q.Where(cond(Schema.Build.AuthorDate, v))
}

// FindByAuthorEmail adds a new filter to the query that will require that
// the AuthorEmail property is equal to the passed value.
func (q *BuildQuery) FindByAuthorEmail(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.AuthorEmail, v))
}

// FindByAuthorName adds a new filter to the query that will require that
// the AuthorName property is equal to the passed value.
func (q *BuildQuery) FindByAuthorName(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.AuthorName, v))
}

// FindByBody adds a new filter to the query that will require that
// the Body property is equal to the passed value.
func (q *BuildQuery) FindByBody(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Body, v))
}

// FindByBranch adds a new filter to the query that will require that
// the Branch property is equal to the passed value.
func (q *BuildQuery) FindByBranch(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Branch, v))
}

// FindByBuildNum adds a new filter to the query that will require that
// the BuildNum property is equal to the passed value.
func (q *BuildQuery) FindByBuildNum(cond kallax.ScalarCond, v int) *BuildQuery {
	return q.Where(cond(Schema.Build.BuildNum, v))
}

// FindByBuildURL adds a new filter to the query that will require that
// the BuildURL property is equal to the passed value.
func (q *BuildQuery) FindByBuildURL(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.BuildURL, v))
}

// FindByCanceled adds a new filter to the query that will require that
// the Canceled property is equal to the passed value.
func (q *BuildQuery) FindByCanceled(v bool) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Canceled, v))
}

// FindByCommitterDate adds a new filter to the query that will require that
// the CommitterDate property is equal to the passed value.
func (q *BuildQuery) FindByCommitterDate(cond kallax.ScalarCond, v time.Time) *BuildQuery {
	return q.Where(cond(Schema.Build.CommitterDate, v))
}

// FindByCommitterEmail adds a new filter to the query that will require that
// the CommitterEmail property is equal to the passed value.
func (q *BuildQuery) FindByCommitterEmail(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.CommitterEmail, v))
}

// FindByCommitterName adds a new filter to the query that will require that
// the CommitterName property is equal to the passed value.
func (q *BuildQuery) FindByCommitterName(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.CommitterName, v))
}

// FindByInfrastructureFail adds a new filter to the query that will require that
// the InfrastructureFail property is equal to the passed value.
func (q *BuildQuery) FindByInfrastructureFail(v bool) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.InfrastructureFail, v))
}

// FindByIsFirstGreenBuild adds a new filter to the query that will require that
// the IsFirstGreenBuild property is equal to the passed value.
func (q *BuildQuery) FindByIsFirstGreenBuild(v bool) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.IsFirstGreenBuild, v))
}

// FindByLifecycle adds a new filter to the query that will require that
// the Lifecycle property is equal to the passed value.
func (q *BuildQuery) FindByLifecycle(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Lifecycle, v))
}

// FindByOSS adds a new filter to the query that will require that
// the OSS property is equal to the passed value.
func (q *BuildQuery) FindByOSS(v bool) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.OSS, v))
}

// FindByOutcome adds a new filter to the query that will require that
// the Outcome property is equal to the passed value.
func (q *BuildQuery) FindByOutcome(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Outcome, v))
}

// FindByParallel adds a new filter to the query that will require that
// the Parallel property is equal to the passed value.
func (q *BuildQuery) FindByParallel(cond kallax.ScalarCond, v int) *BuildQuery {
	return q.Where(cond(Schema.Build.Parallel, v))
}

// FindByPlatform adds a new filter to the query that will require that
// the Platform property is equal to the passed value.
func (q *BuildQuery) FindByPlatform(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Platform, v))
}

// FindByQueuedAt adds a new filter to the query that will require that
// the QueuedAt property is equal to the passed value.
func (q *BuildQuery) FindByQueuedAt(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.QueuedAt, v))
}

// FindByReponame adds a new filter to the query that will require that
// the Reponame property is equal to the passed value.
func (q *BuildQuery) FindByReponame(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Reponame, v))
}

// FindByRetries adds a new filter to the query that will require that
// the Retries property contains all the passed values; if no passed values,
// it will do nothing.
func (q *BuildQuery) FindByRetries(v ...int) *BuildQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Build.Retries, values...))
}

// FindByStartTime adds a new filter to the query that will require that
// the StartTime property is equal to the passed value.
func (q *BuildQuery) FindByStartTime(cond kallax.ScalarCond, v time.Time) *BuildQuery {
	return q.Where(cond(Schema.Build.StartTime, v))
}

// FindByStatus adds a new filter to the query that will require that
// the Status property is equal to the passed value.
func (q *BuildQuery) FindByStatus(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Status, v))
}

// FindByStopTime adds a new filter to the query that will require that
// the StopTime property is equal to the passed value.
func (q *BuildQuery) FindByStopTime(cond kallax.ScalarCond, v time.Time) *BuildQuery {
	return q.Where(cond(Schema.Build.StopTime, v))
}

// FindBySubject adds a new filter to the query that will require that
// the Subject property is equal to the passed value.
func (q *BuildQuery) FindBySubject(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Subject, v))
}

// FindByTimedout adds a new filter to the query that will require that
// the Timedout property is equal to the passed value.
func (q *BuildQuery) FindByTimedout(v bool) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Timedout, v))
}

// FindByUsageQueuedAt adds a new filter to the query that will require that
// the UsageQueuedAt property is equal to the passed value.
func (q *BuildQuery) FindByUsageQueuedAt(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.UsageQueuedAt, v))
}

// FindByUsername adds a new filter to the query that will require that
// the Username property is equal to the passed value.
func (q *BuildQuery) FindByUsername(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Username, v))
}

// FindByVcsRevision adds a new filter to the query that will require that
// the VcsRevision property is equal to the passed value.
func (q *BuildQuery) FindByVcsRevision(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.VcsRevision, v))
}

// FindByVcsTag adds a new filter to the query that will require that
// the VcsTag property is equal to the passed value.
func (q *BuildQuery) FindByVcsTag(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.VcsTag, v))
}

// FindByVCSURL adds a new filter to the query that will require that
// the VCSURL property is equal to the passed value.
func (q *BuildQuery) FindByVCSURL(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.VCSURL, v))
}

// FindByWhy adds a new filter to the query that will require that
// the Why property is equal to the passed value.
func (q *BuildQuery) FindByWhy(v string) *BuildQuery {
	return q.Where(kallax.Eq(Schema.Build.Why, v))
}

// FindByPreviousBuildNum adds a new filter to the query that will require that
// the PreviousBuildNum property is equal to the passed value.
func (q *BuildQuery) FindByPreviousBuildNum(cond kallax.ScalarCond, v int) *BuildQuery {
	return q.Where(cond(Schema.Build.PreviousBuildNum, v))
}

// FindByPreviousSuccessfulBuildNum adds a new filter to the query that will require that
// the PreviousSuccessfulBuildNum property is equal to the passed value.
func (q *BuildQuery) FindByPreviousSuccessfulBuildNum(cond kallax.ScalarCond, v int) *BuildQuery {
	return q.Where(cond(Schema.Build.PreviousSuccessfulBuildNum, v))
}

// FindByPullRequestURLs adds a new filter to the query that will require that
// the PullRequestURLs property contains all the passed values; if no passed values,
// it will do nothing.
func (q *BuildQuery) FindByPullRequestURLs(v ...string) *BuildQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Build.PullRequestURLs, values...))
}

// BuildResultSet is the set of results returned by a query to the
// database.
type BuildResultSet struct {
	ResultSet kallax.ResultSet
	last      *Build
	lastErr   error
}

// NewBuildResultSet creates a new result set for rows of the type
// Build.
func NewBuildResultSet(rs kallax.ResultSet) *BuildResultSet {
	return &BuildResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *BuildResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Build.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Build)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Build")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *BuildResultSet) Get() (*Build, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *BuildResultSet) ForEach(fn func(*Build) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *BuildResultSet) All() ([]*Build, error) {
	var result []*Build
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *BuildResultSet) One() (*Build, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *BuildResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *BuildResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewOutput returns a new instance of Output.
func NewOutput() (record *Output) {
	return new(Output)
}

// GetID returns the primary key of the model.
func (r *Output) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Output) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(&r.ID), nil
	case "type":
		return &r.Output.Type, nil
	case "time":
		return &r.Output.Time, nil
	case "message":
		return &r.Output.Message, nil
	case "url":
		return &r.URL, nil
	case "build_num":
		return &r.BuildNum, nil
	case "username":
		return &r.Username, nil
	case "reponame":
		return &r.Reponame, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Output: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Output) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "type":
		return r.Output.Type, nil
	case "time":
		return r.Output.Time, nil
	case "message":
		return r.Output.Message, nil
	case "url":
		return r.URL, nil
	case "build_num":
		return r.BuildNum, nil
	case "username":
		return r.Username, nil
	case "reponame":
		return r.Reponame, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Output: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Output) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Output has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Output) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Output has no relationships")
}

// OutputStore is the entity to access the records of the type Output
// in the database.
type OutputStore struct {
	*kallax.Store
}

// NewOutputStore creates a new instance of OutputStore
// using a SQL database.
func NewOutputStore(db *sql.DB) *OutputStore {
	return &OutputStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *OutputStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *OutputStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *OutputStore) Debug() *OutputStore {
	return &OutputStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *OutputStore) DebugWith(logger kallax.LoggerFunc) *OutputStore {
	return &OutputStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *OutputStore) DisableCacher() *OutputStore {
	return &OutputStore{s.Store.DisableCacher()}
}

// Insert inserts a Output in the database. A non-persisted object is
// required for this operation.
func (s *OutputStore) Insert(record *Output) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.Time = record.Time.Truncate(time.Microsecond)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Output.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *OutputStore) Update(record *Output, cols ...kallax.SchemaField) (updated int64, err error) {
	record.Time = record.Time.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Output.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *OutputStore) Save(record *Output) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *OutputStore) Delete(record *Output) error {
	return s.Store.Delete(Schema.Output.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *OutputStore) Find(q *OutputQuery) (*OutputResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewOutputResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *OutputStore) MustFind(q *OutputQuery) *OutputResultSet {
	return NewOutputResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *OutputStore) Count(q *OutputQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *OutputStore) MustCount(q *OutputQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *OutputStore) FindOne(q *OutputQuery) (*Output, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *OutputStore) FindAll(q *OutputQuery) ([]*Output, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *OutputStore) MustFindOne(q *OutputQuery) *Output {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Output with the data in the database and
// makes it writable.
func (s *OutputStore) Reload(record *Output) error {
	return s.Store.Reload(Schema.Output.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *OutputStore) Transaction(callback func(*OutputStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&OutputStore{store})
	})
}

// OutputQuery is the object used to create queries for the Output
// entity.
type OutputQuery struct {
	*kallax.BaseQuery
}

// NewOutputQuery returns a new instance of OutputQuery.
func NewOutputQuery() *OutputQuery {
	return &OutputQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Output.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *OutputQuery) Select(columns ...kallax.SchemaField) *OutputQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *OutputQuery) SelectNot(columns ...kallax.SchemaField) *OutputQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *OutputQuery) Copy() *OutputQuery {
	return &OutputQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *OutputQuery) Order(cols ...kallax.ColumnOrder) *OutputQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *OutputQuery) BatchSize(size uint64) *OutputQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *OutputQuery) Limit(n uint64) *OutputQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *OutputQuery) Offset(n uint64) *OutputQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *OutputQuery) Where(cond kallax.Condition) *OutputQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *OutputQuery) FindByID(v ...int64) *OutputQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Output.ID, values...))
}

// FindByType adds a new filter to the query that will require that
// the Type property is equal to the passed value.
func (q *OutputQuery) FindByType(v string) *OutputQuery {
	return q.Where(kallax.Eq(Schema.Output.Type, v))
}

// FindByTime adds a new filter to the query that will require that
// the Time property is equal to the passed value.
func (q *OutputQuery) FindByTime(cond kallax.ScalarCond, v time.Time) *OutputQuery {
	return q.Where(cond(Schema.Output.Time, v))
}

// FindByMessage adds a new filter to the query that will require that
// the Message property is equal to the passed value.
func (q *OutputQuery) FindByMessage(v string) *OutputQuery {
	return q.Where(kallax.Eq(Schema.Output.Message, v))
}

// FindByURL adds a new filter to the query that will require that
// the URL property is equal to the passed value.
func (q *OutputQuery) FindByURL(v string) *OutputQuery {
	return q.Where(kallax.Eq(Schema.Output.URL, v))
}

// FindByBuildNum adds a new filter to the query that will require that
// the BuildNum property is equal to the passed value.
func (q *OutputQuery) FindByBuildNum(cond kallax.ScalarCond, v int) *OutputQuery {
	return q.Where(cond(Schema.Output.BuildNum, v))
}

// FindByUsername adds a new filter to the query that will require that
// the Username property is equal to the passed value.
func (q *OutputQuery) FindByUsername(v string) *OutputQuery {
	return q.Where(kallax.Eq(Schema.Output.Username, v))
}

// FindByReponame adds a new filter to the query that will require that
// the Reponame property is equal to the passed value.
func (q *OutputQuery) FindByReponame(v string) *OutputQuery {
	return q.Where(kallax.Eq(Schema.Output.Reponame, v))
}

// OutputResultSet is the set of results returned by a query to the
// database.
type OutputResultSet struct {
	ResultSet kallax.ResultSet
	last      *Output
	lastErr   error
}

// NewOutputResultSet creates a new result set for rows of the type
// Output.
func NewOutputResultSet(rs kallax.ResultSet) *OutputResultSet {
	return &OutputResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *OutputResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Output.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Output)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Output")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *OutputResultSet) Get() (*Output, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *OutputResultSet) ForEach(fn func(*Output) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *OutputResultSet) All() ([]*Output, error) {
	var result []*Output
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *OutputResultSet) One() (*Output, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *OutputResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *OutputResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewStep returns a new instance of Step.
func NewStep() (record *Step) {
	return new(Step)
}

// GetID returns the primary key of the model.
func (r *Step) GetID() kallax.Identifier {
	return (*kallax.NumericID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Step) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.NumericID)(&r.ID), nil
	case "background":
		return &r.Action.Background, nil
	case "bash_command":
		return types.Nullable(&r.Action.BashCommand), nil
	case "canceled":
		return types.Nullable(&r.Action.Canceled), nil
	case "continue":
		return types.Nullable(&r.Action.Continue), nil
	case "end_time":
		return types.Nullable(&r.Action.EndTime), nil
	case "exit_code":
		return types.Nullable(&r.Action.ExitCode), nil
	case "failed":
		return types.Nullable(&r.Action.Failed), nil
	case "has_output":
		return &r.Action.HasOutput, nil
	case "_index":
		return &r.Action.Index, nil
	case "infrastructure_fail":
		return types.Nullable(&r.Action.InfrastructureFail), nil
	case "messages":
		return types.Slice(&r.Action.Messages), nil
	case "name":
		return &r.Action.Name, nil
	case "output_url":
		return &r.Action.OutputURL, nil
	case "parallel":
		return &r.Action.Parallel, nil
	case "run_time_millis":
		return &r.Action.RunTimeMillis, nil
	case "start_time":
		return types.Nullable(&r.Action.StartTime), nil
	case "status":
		return &r.Action.Status, nil
	case "step":
		return &r.Action.Step, nil
	case "timedout":
		return types.Nullable(&r.Action.Timedout), nil
	case "truncated":
		return &r.Action.Truncated, nil
	case "type":
		return &r.Action.Type, nil
	case "build_num":
		return &r.BuildNum, nil
	case "username":
		return &r.Username, nil
	case "reponame":
		return &r.Reponame, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Step: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Step) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "background":
		return r.Action.Background, nil
	case "bash_command":
		if r.Action.BashCommand == (*string)(nil) {
			return nil, nil
		}
		return r.Action.BashCommand, nil
	case "canceled":
		if r.Action.Canceled == (*bool)(nil) {
			return nil, nil
		}
		return r.Action.Canceled, nil
	case "continue":
		if r.Action.Continue == (*string)(nil) {
			return nil, nil
		}
		return r.Action.Continue, nil
	case "end_time":
		if r.Action.EndTime == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Action.EndTime, nil
	case "exit_code":
		if r.Action.ExitCode == (*int)(nil) {
			return nil, nil
		}
		return r.Action.ExitCode, nil
	case "failed":
		if r.Action.Failed == (*bool)(nil) {
			return nil, nil
		}
		return r.Action.Failed, nil
	case "has_output":
		return r.Action.HasOutput, nil
	case "_index":
		return r.Action.Index, nil
	case "infrastructure_fail":
		if r.Action.InfrastructureFail == (*bool)(nil) {
			return nil, nil
		}
		return r.Action.InfrastructureFail, nil
	case "messages":
		return types.Slice(r.Action.Messages), nil
	case "name":
		return r.Action.Name, nil
	case "output_url":
		return r.Action.OutputURL, nil
	case "parallel":
		return r.Action.Parallel, nil
	case "run_time_millis":
		return r.Action.RunTimeMillis, nil
	case "start_time":
		if r.Action.StartTime == (*time.Time)(nil) {
			return nil, nil
		}
		return r.Action.StartTime, nil
	case "status":
		return r.Action.Status, nil
	case "step":
		return r.Action.Step, nil
	case "timedout":
		if r.Action.Timedout == (*bool)(nil) {
			return nil, nil
		}
		return r.Action.Timedout, nil
	case "truncated":
		return r.Action.Truncated, nil
	case "type":
		return r.Action.Type, nil
	case "build_num":
		return r.BuildNum, nil
	case "username":
		return r.Username, nil
	case "reponame":
		return r.Reponame, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Step: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Step) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Step has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Step) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Step has no relationships")
}

// StepStore is the entity to access the records of the type Step
// in the database.
type StepStore struct {
	*kallax.Store
}

// NewStepStore creates a new instance of StepStore
// using a SQL database.
func NewStepStore(db *sql.DB) *StepStore {
	return &StepStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *StepStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *StepStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *StepStore) Debug() *StepStore {
	return &StepStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *StepStore) DebugWith(logger kallax.LoggerFunc) *StepStore {
	return &StepStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *StepStore) DisableCacher() *StepStore {
	return &StepStore{s.Store.DisableCacher()}
}

// Insert inserts a Step in the database. A non-persisted object is
// required for this operation.
func (s *StepStore) Insert(record *Step) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if record.EndTime != nil {
		record.EndTime = func(t time.Time) *time.Time { return &t }(record.EndTime.Truncate(time.Microsecond))
	}
	if record.StartTime != nil {
		record.StartTime = func(t time.Time) *time.Time { return &t }(record.StartTime.Truncate(time.Microsecond))
	}

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Step.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *StepStore) Update(record *Step, cols ...kallax.SchemaField) (updated int64, err error) {
	if record.EndTime != nil {
		record.EndTime = func(t time.Time) *time.Time { return &t }(record.EndTime.Truncate(time.Microsecond))
	}
	if record.StartTime != nil {
		record.StartTime = func(t time.Time) *time.Time { return &t }(record.StartTime.Truncate(time.Microsecond))
	}

	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Step.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *StepStore) Save(record *Step) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *StepStore) Delete(record *Step) error {
	return s.Store.Delete(Schema.Step.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *StepStore) Find(q *StepQuery) (*StepResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewStepResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *StepStore) MustFind(q *StepQuery) *StepResultSet {
	return NewStepResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *StepStore) Count(q *StepQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *StepStore) MustCount(q *StepQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *StepStore) FindOne(q *StepQuery) (*Step, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *StepStore) FindAll(q *StepQuery) ([]*Step, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *StepStore) MustFindOne(q *StepQuery) *Step {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Step with the data in the database and
// makes it writable.
func (s *StepStore) Reload(record *Step) error {
	return s.Store.Reload(Schema.Step.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *StepStore) Transaction(callback func(*StepStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&StepStore{store})
	})
}

// StepQuery is the object used to create queries for the Step
// entity.
type StepQuery struct {
	*kallax.BaseQuery
}

// NewStepQuery returns a new instance of StepQuery.
func NewStepQuery() *StepQuery {
	return &StepQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Step.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *StepQuery) Select(columns ...kallax.SchemaField) *StepQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *StepQuery) SelectNot(columns ...kallax.SchemaField) *StepQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *StepQuery) Copy() *StepQuery {
	return &StepQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *StepQuery) Order(cols ...kallax.ColumnOrder) *StepQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *StepQuery) BatchSize(size uint64) *StepQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *StepQuery) Limit(n uint64) *StepQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *StepQuery) Offset(n uint64) *StepQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *StepQuery) Where(cond kallax.Condition) *StepQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *StepQuery) FindByID(v ...int64) *StepQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Step.ID, values...))
}

// FindByBackground adds a new filter to the query that will require that
// the Background property is equal to the passed value.
func (q *StepQuery) FindByBackground(v bool) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Background, v))
}

// FindByEndTime adds a new filter to the query that will require that
// the EndTime property is equal to the passed value.
func (q *StepQuery) FindByEndTime(cond kallax.ScalarCond, v time.Time) *StepQuery {
	return q.Where(cond(Schema.Step.EndTime, v))
}

// FindByHasOutput adds a new filter to the query that will require that
// the HasOutput property is equal to the passed value.
func (q *StepQuery) FindByHasOutput(v bool) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.HasOutput, v))
}

// FindByIndex adds a new filter to the query that will require that
// the Index property is equal to the passed value.
func (q *StepQuery) FindByIndex(cond kallax.ScalarCond, v int) *StepQuery {
	return q.Where(cond(Schema.Step.Index, v))
}

// FindByMessages adds a new filter to the query that will require that
// the Messages property contains all the passed values; if no passed values,
// it will do nothing.
func (q *StepQuery) FindByMessages(v ...string) *StepQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Step.Messages, values...))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *StepQuery) FindByName(v string) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Name, v))
}

// FindByOutputURL adds a new filter to the query that will require that
// the OutputURL property is equal to the passed value.
func (q *StepQuery) FindByOutputURL(v string) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.OutputURL, v))
}

// FindByParallel adds a new filter to the query that will require that
// the Parallel property is equal to the passed value.
func (q *StepQuery) FindByParallel(v bool) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Parallel, v))
}

// FindByRunTimeMillis adds a new filter to the query that will require that
// the RunTimeMillis property is equal to the passed value.
func (q *StepQuery) FindByRunTimeMillis(cond kallax.ScalarCond, v int) *StepQuery {
	return q.Where(cond(Schema.Step.RunTimeMillis, v))
}

// FindByStartTime adds a new filter to the query that will require that
// the StartTime property is equal to the passed value.
func (q *StepQuery) FindByStartTime(cond kallax.ScalarCond, v time.Time) *StepQuery {
	return q.Where(cond(Schema.Step.StartTime, v))
}

// FindByStatus adds a new filter to the query that will require that
// the Status property is equal to the passed value.
func (q *StepQuery) FindByStatus(v string) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Status, v))
}

// FindByStep adds a new filter to the query that will require that
// the Step property is equal to the passed value.
func (q *StepQuery) FindByStep(cond kallax.ScalarCond, v int) *StepQuery {
	return q.Where(cond(Schema.Step.Step, v))
}

// FindByTruncated adds a new filter to the query that will require that
// the Truncated property is equal to the passed value.
func (q *StepQuery) FindByTruncated(v bool) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Truncated, v))
}

// FindByType adds a new filter to the query that will require that
// the Type property is equal to the passed value.
func (q *StepQuery) FindByType(v string) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Type, v))
}

// FindByBuildNum adds a new filter to the query that will require that
// the BuildNum property is equal to the passed value.
func (q *StepQuery) FindByBuildNum(cond kallax.ScalarCond, v int) *StepQuery {
	return q.Where(cond(Schema.Step.BuildNum, v))
}

// FindByUsername adds a new filter to the query that will require that
// the Username property is equal to the passed value.
func (q *StepQuery) FindByUsername(v string) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Username, v))
}

// FindByReponame adds a new filter to the query that will require that
// the Reponame property is equal to the passed value.
func (q *StepQuery) FindByReponame(v string) *StepQuery {
	return q.Where(kallax.Eq(Schema.Step.Reponame, v))
}

// StepResultSet is the set of results returned by a query to the
// database.
type StepResultSet struct {
	ResultSet kallax.ResultSet
	last      *Step
	lastErr   error
}

// NewStepResultSet creates a new result set for rows of the type
// Step.
func NewStepResultSet(rs kallax.ResultSet) *StepResultSet {
	return &StepResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *StepResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Step.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Step)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Step")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *StepResultSet) Get() (*Step, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *StepResultSet) ForEach(fn func(*Step) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *StepResultSet) All() ([]*Step, error) {
	var result []*Step
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *StepResultSet) One() (*Step, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *StepResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *StepResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Build  *schemaBuild
	Output *schemaOutput
	Step   *schemaStep
}

type schemaBuild struct {
	*kallax.BaseSchema
	ID                         kallax.SchemaField
	AuthorDate                 kallax.SchemaField
	AuthorEmail                kallax.SchemaField
	AuthorName                 kallax.SchemaField
	Body                       kallax.SchemaField
	Branch                     kallax.SchemaField
	BuildNum                   kallax.SchemaField
	BuildParameters            kallax.SchemaField
	BuildTimeMillis            kallax.SchemaField
	BuildURL                   kallax.SchemaField
	Canceled                   kallax.SchemaField
	CircleYML                  *schemaBuildCircleYML
	CommitterDate              kallax.SchemaField
	CommitterEmail             kallax.SchemaField
	CommitterName              kallax.SchemaField
	Compare                    kallax.SchemaField
	DontBuild                  kallax.SchemaField
	Failed                     kallax.SchemaField
	FeatureFlags               kallax.SchemaField
	InfrastructureFail         kallax.SchemaField
	IsFirstGreenBuild          kallax.SchemaField
	JobName                    kallax.SchemaField
	Lifecycle                  kallax.SchemaField
	OSS                        kallax.SchemaField
	Outcome                    kallax.SchemaField
	Parallel                   kallax.SchemaField
	Platform                   kallax.SchemaField
	QueuedAt                   kallax.SchemaField
	Reponame                   kallax.SchemaField
	Retries                    kallax.SchemaField
	RetryOf                    kallax.SchemaField
	StartTime                  kallax.SchemaField
	Status                     kallax.SchemaField
	StopTime                   kallax.SchemaField
	Subject                    kallax.SchemaField
	Timedout                   kallax.SchemaField
	UsageQueuedAt              kallax.SchemaField
	Username                   kallax.SchemaField
	VcsRevision                kallax.SchemaField
	VcsTag                     kallax.SchemaField
	VCSURL                     kallax.SchemaField
	Why                        kallax.SchemaField
	PreviousBuildNum           kallax.SchemaField
	PreviousSuccessfulBuildNum kallax.SchemaField
	PullRequestURLs            kallax.SchemaField
}

type schemaOutput struct {
	*kallax.BaseSchema
	ID       kallax.SchemaField
	Type     kallax.SchemaField
	Time     kallax.SchemaField
	Message  kallax.SchemaField
	URL      kallax.SchemaField
	BuildNum kallax.SchemaField
	Username kallax.SchemaField
	Reponame kallax.SchemaField
}

type schemaStep struct {
	*kallax.BaseSchema
	ID                 kallax.SchemaField
	Background         kallax.SchemaField
	BashCommand        kallax.SchemaField
	Canceled           kallax.SchemaField
	Continue           kallax.SchemaField
	EndTime            kallax.SchemaField
	ExitCode           kallax.SchemaField
	Failed             kallax.SchemaField
	HasOutput          kallax.SchemaField
	Index              kallax.SchemaField
	InfrastructureFail kallax.SchemaField
	Messages           kallax.SchemaField
	Name               kallax.SchemaField
	OutputURL          kallax.SchemaField
	Parallel           kallax.SchemaField
	RunTimeMillis      kallax.SchemaField
	StartTime          kallax.SchemaField
	Status             kallax.SchemaField
	Step               kallax.SchemaField
	Timedout           kallax.SchemaField
	Truncated          kallax.SchemaField
	Type               kallax.SchemaField
	BuildNum           kallax.SchemaField
	Username           kallax.SchemaField
	Reponame           kallax.SchemaField
}

type schemaBuildCircleYML struct {
	*kallax.BaseSchemaField
	String kallax.SchemaField
}

var Schema = &schema{
	Build: &schemaBuild{
		BaseSchema: kallax.NewBaseSchema(
			"builds",
			"__build",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Build)
			},
			true,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("author_date"),
			kallax.NewSchemaField("author_email"),
			kallax.NewSchemaField("author_name"),
			kallax.NewSchemaField("body"),
			kallax.NewSchemaField("branch"),
			kallax.NewSchemaField("build_num"),
			kallax.NewSchemaField("build_parameters"),
			kallax.NewSchemaField("build_time_millis"),
			kallax.NewSchemaField("build_url"),
			kallax.NewSchemaField("canceled"),
			kallax.NewSchemaField("circle_yml"),
			kallax.NewSchemaField("committer_date"),
			kallax.NewSchemaField("committer_email"),
			kallax.NewSchemaField("committer_name"),
			kallax.NewSchemaField("compare"),
			kallax.NewSchemaField("dont_build"),
			kallax.NewSchemaField("failed"),
			kallax.NewSchemaField("feature_flags"),
			kallax.NewSchemaField("infrastructure_fail"),
			kallax.NewSchemaField("is_first_green_build"),
			kallax.NewSchemaField("job_name"),
			kallax.NewSchemaField("lifecycle"),
			kallax.NewSchemaField("oss"),
			kallax.NewSchemaField("outcome"),
			kallax.NewSchemaField("parallel"),
			kallax.NewSchemaField("platform"),
			kallax.NewSchemaField("queued_at"),
			kallax.NewSchemaField("reponame"),
			kallax.NewSchemaField("retries"),
			kallax.NewSchemaField("retry_of"),
			kallax.NewSchemaField("start_time"),
			kallax.NewSchemaField("status"),
			kallax.NewSchemaField("stop_time"),
			kallax.NewSchemaField("subject"),
			kallax.NewSchemaField("timedout"),
			kallax.NewSchemaField("usage_queued_at"),
			kallax.NewSchemaField("username"),
			kallax.NewSchemaField("vcs_revision"),
			kallax.NewSchemaField("vcs_tag"),
			kallax.NewSchemaField("vcsurl"),
			kallax.NewSchemaField("why"),
			kallax.NewSchemaField("previous_build_num"),
			kallax.NewSchemaField("previous_successful_build_num"),
			kallax.NewSchemaField("pull_request_urls"),
		),
		ID:              kallax.NewSchemaField("id"),
		AuthorDate:      kallax.NewSchemaField("author_date"),
		AuthorEmail:     kallax.NewSchemaField("author_email"),
		AuthorName:      kallax.NewSchemaField("author_name"),
		Body:            kallax.NewSchemaField("body"),
		Branch:          kallax.NewSchemaField("branch"),
		BuildNum:        kallax.NewSchemaField("build_num"),
		BuildParameters: kallax.NewSchemaField("build_parameters"),
		BuildTimeMillis: kallax.NewSchemaField("build_time_millis"),
		BuildURL:        kallax.NewSchemaField("build_url"),
		Canceled:        kallax.NewSchemaField("canceled"),
		CircleYML: &schemaBuildCircleYML{
			BaseSchemaField: kallax.NewSchemaField("circle_yml").(*kallax.BaseSchemaField),
			String:          kallax.NewJSONSchemaKey(kallax.JSONText, "build", "circle_yml", "string"),
		},
		CommitterDate:              kallax.NewSchemaField("committer_date"),
		CommitterEmail:             kallax.NewSchemaField("committer_email"),
		CommitterName:              kallax.NewSchemaField("committer_name"),
		Compare:                    kallax.NewSchemaField("compare"),
		DontBuild:                  kallax.NewSchemaField("dont_build"),
		Failed:                     kallax.NewSchemaField("failed"),
		FeatureFlags:               kallax.NewSchemaField("feature_flags"),
		InfrastructureFail:         kallax.NewSchemaField("infrastructure_fail"),
		IsFirstGreenBuild:          kallax.NewSchemaField("is_first_green_build"),
		JobName:                    kallax.NewSchemaField("job_name"),
		Lifecycle:                  kallax.NewSchemaField("lifecycle"),
		OSS:                        kallax.NewSchemaField("oss"),
		Outcome:                    kallax.NewSchemaField("outcome"),
		Parallel:                   kallax.NewSchemaField("parallel"),
		Platform:                   kallax.NewSchemaField("platform"),
		QueuedAt:                   kallax.NewSchemaField("queued_at"),
		Reponame:                   kallax.NewSchemaField("reponame"),
		Retries:                    kallax.NewSchemaField("retries"),
		RetryOf:                    kallax.NewSchemaField("retry_of"),
		StartTime:                  kallax.NewSchemaField("start_time"),
		Status:                     kallax.NewSchemaField("status"),
		StopTime:                   kallax.NewSchemaField("stop_time"),
		Subject:                    kallax.NewSchemaField("subject"),
		Timedout:                   kallax.NewSchemaField("timedout"),
		UsageQueuedAt:              kallax.NewSchemaField("usage_queued_at"),
		Username:                   kallax.NewSchemaField("username"),
		VcsRevision:                kallax.NewSchemaField("vcs_revision"),
		VcsTag:                     kallax.NewSchemaField("vcs_tag"),
		VCSURL:                     kallax.NewSchemaField("vcsurl"),
		Why:                        kallax.NewSchemaField("why"),
		PreviousBuildNum:           kallax.NewSchemaField("previous_build_num"),
		PreviousSuccessfulBuildNum: kallax.NewSchemaField("previous_successful_build_num"),
		PullRequestURLs:            kallax.NewSchemaField("pull_request_urls"),
	},
	Output: &schemaOutput{
		BaseSchema: kallax.NewBaseSchema(
			"outputs",
			"__output",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Output)
			},
			true,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("time"),
			kallax.NewSchemaField("message"),
			kallax.NewSchemaField("url"),
			kallax.NewSchemaField("build_num"),
			kallax.NewSchemaField("username"),
			kallax.NewSchemaField("reponame"),
		),
		ID:       kallax.NewSchemaField("id"),
		Type:     kallax.NewSchemaField("type"),
		Time:     kallax.NewSchemaField("time"),
		Message:  kallax.NewSchemaField("message"),
		URL:      kallax.NewSchemaField("url"),
		BuildNum: kallax.NewSchemaField("build_num"),
		Username: kallax.NewSchemaField("username"),
		Reponame: kallax.NewSchemaField("reponame"),
	},
	Step: &schemaStep{
		BaseSchema: kallax.NewBaseSchema(
			"steps",
			"__step",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Step)
			},
			true,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("background"),
			kallax.NewSchemaField("bash_command"),
			kallax.NewSchemaField("canceled"),
			kallax.NewSchemaField("continue"),
			kallax.NewSchemaField("end_time"),
			kallax.NewSchemaField("exit_code"),
			kallax.NewSchemaField("failed"),
			kallax.NewSchemaField("has_output"),
			kallax.NewSchemaField("_index"),
			kallax.NewSchemaField("infrastructure_fail"),
			kallax.NewSchemaField("messages"),
			kallax.NewSchemaField("name"),
			kallax.NewSchemaField("output_url"),
			kallax.NewSchemaField("parallel"),
			kallax.NewSchemaField("run_time_millis"),
			kallax.NewSchemaField("start_time"),
			kallax.NewSchemaField("status"),
			kallax.NewSchemaField("step"),
			kallax.NewSchemaField("timedout"),
			kallax.NewSchemaField("truncated"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("build_num"),
			kallax.NewSchemaField("username"),
			kallax.NewSchemaField("reponame"),
		),
		ID:                 kallax.NewSchemaField("id"),
		Background:         kallax.NewSchemaField("background"),
		BashCommand:        kallax.NewSchemaField("bash_command"),
		Canceled:           kallax.NewSchemaField("canceled"),
		Continue:           kallax.NewSchemaField("continue"),
		EndTime:            kallax.NewSchemaField("end_time"),
		ExitCode:           kallax.NewSchemaField("exit_code"),
		Failed:             kallax.NewSchemaField("failed"),
		HasOutput:          kallax.NewSchemaField("has_output"),
		Index:              kallax.NewSchemaField("_index"),
		InfrastructureFail: kallax.NewSchemaField("infrastructure_fail"),
		Messages:           kallax.NewSchemaField("messages"),
		Name:               kallax.NewSchemaField("name"),
		OutputURL:          kallax.NewSchemaField("output_url"),
		Parallel:           kallax.NewSchemaField("parallel"),
		RunTimeMillis:      kallax.NewSchemaField("run_time_millis"),
		StartTime:          kallax.NewSchemaField("start_time"),
		Status:             kallax.NewSchemaField("status"),
		Step:               kallax.NewSchemaField("step"),
		Timedout:           kallax.NewSchemaField("timedout"),
		Truncated:          kallax.NewSchemaField("truncated"),
		Type:               kallax.NewSchemaField("type"),
		BuildNum:           kallax.NewSchemaField("build_num"),
		Username:           kallax.NewSchemaField("username"),
		Reponame:           kallax.NewSchemaField("reponame"),
	},
}
